/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { __assign } from "tslib";
import { Loci } from '../../mol-model/loci';
import { BoundaryHelper } from '../../mol-math/geometry/boundary-helper';
import { StructureElement } from '../../mol-model/structure';
// TODO: make this customizable somewhere?
var DefaultCameraFocusOptions = {
    minRadius: 5,
    extraRadius: 4,
    durationMs: 250
};
var CameraManager = /** @class */ (function () {
    function CameraManager(plugin) {
        this.plugin = plugin;
        this.boundaryHelper = new BoundaryHelper('98');
    }
    CameraManager.prototype.transformedLoci = function (loci) {
        var _a, _b;
        if (StructureElement.Loci.is(loci)) {
            // use decorated (including 3d transforms) parent structure
            var parent_1 = (_b = (_a = this.plugin.helpers.substructureParent.get(loci.structure)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
            if (parent_1)
                loci = StructureElement.Loci.remap(loci, parent_1);
        }
        return loci;
    };
    CameraManager.prototype.focusRenderObjects = function (objects, options) {
        if (!objects)
            return;
        var spheres = [];
        for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
            var o = objects_1[_i];
            var s = o.values.boundingSphere.ref.value;
            if (s.radius === 0)
                continue;
            spheres.push(s);
        }
        this.focusSpheres(spheres, function (s) { return s; }, options);
    };
    CameraManager.prototype.focusLoci = function (loci, options) {
        // TODO: allow computation of principal axes here?
        // perhaps have an optimized function, that does exact axes small Loci and approximate/sampled from big ones?
        var sphere;
        if (Array.isArray(loci) && loci.length > 1) {
            var spheres = [];
            for (var _i = 0, loci_1 = loci; _i < loci_1.length; _i++) {
                var l = loci_1[_i];
                var s = Loci.getBoundingSphere(this.transformedLoci(l));
                if (s)
                    spheres.push(s);
            }
            if (spheres.length === 0)
                return;
            this.boundaryHelper.reset();
            for (var _a = 0, spheres_1 = spheres; _a < spheres_1.length; _a++) {
                var s = spheres_1[_a];
                this.boundaryHelper.includeSphere(s);
            }
            this.boundaryHelper.finishedIncludeStep();
            for (var _b = 0, spheres_2 = spheres; _b < spheres_2.length; _b++) {
                var s = spheres_2[_b];
                this.boundaryHelper.radiusSphere(s);
            }
            sphere = this.boundaryHelper.getSphere();
        }
        else if (Array.isArray(loci)) {
            if (loci.length === 0)
                return;
            sphere = Loci.getBoundingSphere(this.transformedLoci(loci[0]));
        }
        else {
            sphere = Loci.getBoundingSphere(this.transformedLoci(loci));
        }
        if (sphere) {
            this.focusSphere(sphere, options);
        }
    };
    CameraManager.prototype.focusSpheres = function (xs, sphere, options) {
        var spheres = [];
        for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {
            var x = xs_1[_i];
            var s = sphere(x);
            if (s)
                spheres.push(s);
        }
        if (spheres.length === 0)
            return;
        if (spheres.length === 1)
            return this.focusSphere(spheres[0], options);
        this.boundaryHelper.reset();
        for (var _a = 0, spheres_3 = spheres; _a < spheres_3.length; _a++) {
            var s = spheres_3[_a];
            this.boundaryHelper.includeSphere(s);
        }
        this.boundaryHelper.finishedIncludeStep();
        for (var _b = 0, spheres_4 = spheres; _b < spheres_4.length; _b++) {
            var s = spheres_4[_b];
            this.boundaryHelper.radiusSphere(s);
        }
        this.focusSphere(this.boundaryHelper.getSphere(), options);
    };
    CameraManager.prototype.focusSphere = function (sphere, options) {
        var _a, _b, _c, _d;
        var _e = __assign(__assign({}, DefaultCameraFocusOptions), options), extraRadius = _e.extraRadius, minRadius = _e.minRadius, durationMs = _e.durationMs;
        var radius = Math.max(sphere.radius + extraRadius, minRadius);
        if (options === null || options === void 0 ? void 0 : options.principalAxes) {
            var _f = options === null || options === void 0 ? void 0 : options.principalAxes.boxAxes, origin_1 = _f.origin, dirA = _f.dirA, dirC = _f.dirC;
            var snapshot = (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.camera.getFocus(origin_1, radius, dirA, dirC);
            (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.requestCameraReset({ durationMs: durationMs, snapshot: snapshot });
            // this.plugin.canvas3d?.camera.focus(origin, radius, durationMs, dirA, dirC);
        }
        else {
            var snapshot = (_c = this.plugin.canvas3d) === null || _c === void 0 ? void 0 : _c.camera.getFocus(sphere.center, radius);
            (_d = this.plugin.canvas3d) === null || _d === void 0 ? void 0 : _d.requestCameraReset({ durationMs: durationMs, snapshot: snapshot });
            // this.plugin.canvas3d?.camera.focus(sphere.center, radius, durationMs);
        }
    };
    CameraManager.prototype.setSnapshot = function (snapshot, durationMs) {
        var _a;
        // TODO: setState and requestCameraReset are very similar now: unify them?
        (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.requestCameraReset({ snapshot: snapshot, durationMs: durationMs });
    };
    CameraManager.prototype.reset = function (snapshot, durationMs) {
        var _a;
        (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.requestCameraReset({ snapshot: snapshot, durationMs: durationMs });
    };
    return CameraManager;
}());
export { CameraManager };
