/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { __awaiter, __generator, __spreadArray } from "tslib";
import { StateAction, StateSelection } from '../../mol-state';
import { Task } from '../../mol-task';
import { ParamDefinition as PD } from '../../mol-util/param-definition';
import { PresetStructureRepresentations, StructureRepresentationPresetProvider } from '../builder/structure/representation-preset';
import { BuiltInTrajectoryFormats } from '../formats/trajectory';
import { RootStructureDefinition } from '../helpers/root-structure';
import { PluginStateObject } from '../objects';
import { StateTransforms } from '../transforms';
import { CustomModelProperties, CustomStructureProperties, TrajectoryFromModelAndCoordinates } from '../transforms/model';
import { Asset } from '../../mol-util/assets';
import { PluginConfig } from '../../mol-plugin/config';
import { getFileInfo } from '../../mol-util/file-info';
import { assertUnreachable } from '../../mol-util/type-helpers';
var DownloadModelRepresentationOptions = function (plugin) {
    var representationDefault = plugin.config.get(PluginConfig.Structure.DefaultRepresentationPreset) || PresetStructureRepresentations.auto.id;
    return PD.Group({
        type: RootStructureDefinition.getParams(void 0, 'auto').type,
        representation: PD.Select(representationDefault, plugin.builders.structure.representation.getPresets().map(function (p) { return [p.id, p.display.name, p.display.group]; }), { description: 'Which representation preset to use.' }),
        representationParams: PD.Group(StructureRepresentationPresetProvider.CommonParams, { isHidden: true }),
        asTrajectory: PD.Optional(PD.Boolean(false, { description: 'Load all entries into a single trajectory.' }))
    }, { isExpanded: false });
};
export var PdbDownloadProvider = {
    'rcsb': PD.Group({
        encoding: PD.Select('bcif', PD.arrayToOptions(['cif', 'bcif'])),
    }, { label: 'RCSB PDB', isFlat: true }),
    'pdbe': PD.Group({
        variant: PD.Select('updated-bcif', [['updated-bcif', 'Updated (bcif)'], ['updated', 'Updated'], ['archival', 'Archival']]),
    }, { label: 'PDBe', isFlat: true }),
    'pdbj': PD.EmptyGroup({ label: 'PDBj' }),
};
export { DownloadStructure };
var DownloadStructure = StateAction.build({
    from: PluginStateObject.Root,
    display: { name: 'Download Structure', description: 'Load a structure from the provided source and create its representation.' },
    params: function (_, plugin) {
        var options = DownloadModelRepresentationOptions(plugin);
        var defaultPdbProvider = plugin.config.get(PluginConfig.Download.DefaultPdbProvider) || 'pdbe';
        return {
            source: PD.MappedStatic('pdb', {
                'pdb': PD.Group({
                    provider: PD.Group({
                        id: PD.Text('1tqn', { label: 'PDB Id(s)', description: 'One or more comma/space separated PDB ids.' }),
                        server: PD.MappedStatic(defaultPdbProvider, PdbDownloadProvider),
                    }, { pivot: 'id' }),
                    options: options
                }, { isFlat: true, label: 'PDB' }),
                'pdb-dev': PD.Group({
                    provider: PD.Group({
                        id: PD.Text('PDBDEV_00000001', { label: 'PDBDev Id(s)', description: 'One or more comma/space separated ids.' }),
                        encoding: PD.Select('bcif', PD.arrayToOptions(['cif', 'bcif'])),
                    }, { pivot: 'id' }),
                    options: options
                }, { isFlat: true, label: 'PDBDEV' }),
                'swissmodel': PD.Group({
                    id: PD.Text('Q9Y2I8', { label: 'UniProtKB AC(s)', description: 'One or more comma/space separated ACs.' }),
                    options: options
                }, { isFlat: true, label: 'SWISS-MODEL', description: 'Loads the best homology model or experimental structure' }),
                'alphafolddb': PD.Group({
                    id: PD.Text('Q8W3K0', { label: 'UniProtKB AC(s)', description: 'One or more comma/space separated ACs.' }),
                    options: options
                }, { isFlat: true, label: 'AlphaFold DB', description: 'Loads the predicted model if available' }),
                'modelarchive': PD.Group({
                    id: PD.Text('ma-bak-cepc-0003', { label: 'Accession Code(s)', description: 'One or more comma/space separated ACs.' }),
                    options: options
                }, { isFlat: true, label: 'Model Archive' }),
                'pubchem': PD.Group({
                    id: PD.Text('2244,2245', { label: 'PubChem ID', description: 'One or more comma/space separated IDs.' }),
                    options: options
                }, { isFlat: true, label: 'PubChem', description: 'Loads 3D conformer from PubChem.' }),
                'url': PD.Group({
                    url: PD.Url(''),
                    format: PD.Select('mmcif', PD.arrayToOptions(BuiltInTrajectoryFormats.map(function (f) { return f[0]; }), function (f) { return f; })),
                    isBinary: PD.Boolean(false),
                    options: options
                }, { isFlat: true, label: 'URL' })
            })
        };
    }
})(function (_a, plugin) {
    var params = _a.params, state = _a.state;
    return Task.create('Download Structure', function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
        var src, downloadParams, asTrajectory, format, _a, representationPreset, showUnitcell, structure;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    plugin.behaviors.layout.leftPanelTabName.next('data');
                    src = params.source;
                    asTrajectory = false, format = 'mmcif';
                    _a = src.name;
                    switch (_a) {
                        case 'url': return [3 /*break*/, 1];
                        case 'pdb': return [3 /*break*/, 2];
                        case 'pdb-dev': return [3 /*break*/, 4];
                        case 'swissmodel': return [3 /*break*/, 6];
                        case 'alphafolddb': return [3 /*break*/, 8];
                        case 'modelarchive': return [3 /*break*/, 10];
                        case 'pubchem': return [3 /*break*/, 12];
                    }
                    return [3 /*break*/, 14];
                case 1:
                    downloadParams = [{ url: src.params.url, isBinary: src.params.isBinary }];
                    format = src.params.format;
                    return [3 /*break*/, 15];
                case 2: return [4 /*yield*/, (src.params.provider.server.name === 'pdbe'
                        ? getPdbeDownloadParams(src)
                        : src.params.provider.server.name === 'pdbj'
                            ? getPdbjDownloadParams(src)
                            : src.params.provider.server.name === 'rcsb'
                                ? getRcsbDownloadParams(src)
                                : assertUnreachable(src))];
                case 3:
                    downloadParams = _b.sent();
                    asTrajectory = !!src.params.options.asTrajectory;
                    return [3 /*break*/, 15];
                case 4: return [4 /*yield*/, getDownloadParams(src.params.provider.id, function (id) {
                        var nId = id.toUpperCase().startsWith('PDBDEV_') ? id : "PDBDEV_".concat(id.padStart(8, '0'));
                        return src.params.provider.encoding === 'bcif'
                            ? "https://pdb-dev.wwpdb.org/bcif/".concat(nId.toUpperCase(), ".bcif")
                            : "https://pdb-dev.wwpdb.org/cif/".concat(nId.toUpperCase(), ".cif");
                    }, function (id) { return id.toUpperCase().startsWith('PDBDEV_') ? id : "PDBDEV_".concat(id.padStart(8, '0')); }, src.params.provider.encoding === 'bcif')];
                case 5:
                    downloadParams = _b.sent();
                    asTrajectory = !!src.params.options.asTrajectory;
                    return [3 /*break*/, 15];
                case 6: return [4 /*yield*/, getDownloadParams(src.params.id, function (id) { return "https://swissmodel.expasy.org/repository/uniprot/".concat(id.toUpperCase(), ".pdb"); }, function (id) { return "SWISS-MODEL: ".concat(id); }, false)];
                case 7:
                    downloadParams = _b.sent();
                    asTrajectory = !!src.params.options.asTrajectory;
                    format = 'pdb';
                    return [3 /*break*/, 15];
                case 8: return [4 /*yield*/, getDownloadParams(src.params.id, function (id) { return __awaiter(void 0, void 0, void 0, function () {
                        var url, info;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    url = "https://www.alphafold.ebi.ac.uk/api/prediction/".concat(id.toUpperCase());
                                    return [4 /*yield*/, plugin.runTask(plugin.fetch({ url: url, type: 'json' }))];
                                case 1:
                                    info = _a.sent();
                                    if (Array.isArray(info) && info.length > 0)
                                        return [2 /*return*/, info[0].cifUrl];
                                    throw new Error("No AlphaFold DB entry for '".concat(id, "'"));
                            }
                        });
                    }); }, function (id) { return "AlphaFold DB: ".concat(id); }, false)];
                case 9:
                    downloadParams = _b.sent();
                    asTrajectory = !!src.params.options.asTrajectory;
                    format = 'mmcif';
                    return [3 /*break*/, 15];
                case 10: return [4 /*yield*/, getDownloadParams(src.params.id, function (id) { return "https://www.modelarchive.org/doi/10.5452/".concat(id.toLowerCase(), ".cif"); }, function (id) { return "Model Archive: ".concat(id); }, false)];
                case 11:
                    downloadParams = _b.sent();
                    asTrajectory = !!src.params.options.asTrajectory;
                    format = 'mmcif';
                    return [3 /*break*/, 15];
                case 12: return [4 /*yield*/, getDownloadParams(src.params.id, function (id) { return "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/CID/".concat(id.trim(), "/record/SDF/?record_type=3d"); }, function (id) { return "PubChem: ".concat(id); }, false)];
                case 13:
                    downloadParams = _b.sent();
                    asTrajectory = !!src.params.options.asTrajectory;
                    format = 'mol';
                    return [3 /*break*/, 15];
                case 14: throw new Error("".concat(src.name, " not supported."));
                case 15:
                    representationPreset = params.source.params.options.representation || plugin.config.get(PluginConfig.Structure.DefaultRepresentationPreset) || PresetStructureRepresentations.auto.id;
                    showUnitcell = representationPreset !== PresetStructureRepresentations.empty.id;
                    structure = src.params.options.type.name === 'auto' ? void 0 : src.params.options.type;
                    return [4 /*yield*/, state.transaction(function () { return __awaiter(void 0, void 0, void 0, function () {
                            var blob, trajectory, _i, downloadParams_1, download, data, provider, trajectory;
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        if (!(downloadParams.length > 0 && asTrajectory)) return [3 /*break*/, 4];
                                        return [4 /*yield*/, plugin.builders.data.downloadBlob({
                                                sources: downloadParams.map(function (src, i) { return ({ id: '' + i, url: src.url, isBinary: src.isBinary }); }),
                                                maxConcurrency: 6
                                            }, { state: { isGhost: true } })];
                                    case 1:
                                        blob = _b.sent();
                                        return [4 /*yield*/, plugin.builders.structure.parseTrajectory(blob, { formats: downloadParams.map(function (_, i) { return ({ id: '' + i, format: 'cif' }); }) })];
                                    case 2:
                                        trajectory = _b.sent();
                                        return [4 /*yield*/, plugin.builders.structure.hierarchy.applyPreset(trajectory, 'default', {
                                                structure: structure,
                                                showUnitcell: showUnitcell,
                                                representationPreset: representationPreset,
                                                representationPresetParams: params.source.params.options.representationParams
                                            })];
                                    case 3:
                                        _b.sent();
                                        return [3 /*break*/, 10];
                                    case 4:
                                        _i = 0, downloadParams_1 = downloadParams;
                                        _b.label = 5;
                                    case 5:
                                        if (!(_i < downloadParams_1.length)) return [3 /*break*/, 10];
                                        download = downloadParams_1[_i];
                                        return [4 /*yield*/, plugin.builders.data.download(download, { state: { isGhost: true } })];
                                    case 6:
                                        data = _b.sent();
                                        provider = format === 'auto'
                                            ? plugin.dataFormats.auto(getFileInfo(Asset.getUrl(download.url)), (_a = data.cell) === null || _a === void 0 ? void 0 : _a.obj)
                                            : plugin.dataFormats.get(format);
                                        if (!provider)
                                            throw new Error('unknown file format');
                                        return [4 /*yield*/, plugin.builders.structure.parseTrajectory(data, provider)];
                                    case 7:
                                        trajectory = _b.sent();
                                        return [4 /*yield*/, plugin.builders.structure.hierarchy.applyPreset(trajectory, 'default', {
                                                structure: structure,
                                                showUnitcell: showUnitcell,
                                                representationPreset: representationPreset,
                                                representationPresetParams: params.source.params.options.representationParams
                                            })];
                                    case 8:
                                        _b.sent();
                                        _b.label = 9;
                                    case 9:
                                        _i++;
                                        return [3 /*break*/, 5];
                                    case 10: return [2 /*return*/];
                                }
                            });
                        }); }).runInContext(ctx)];
                case 16:
                    _b.sent();
                    return [2 /*return*/];
            }
        });
    }); });
});
function getDownloadParams(src, url, label, isBinary) {
    return __awaiter(this, void 0, void 0, function () {
        var ids, ret, _i, ids_1, id, _a, _b, _c, _d;
        var _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    ids = src.split(/[,\s]/).map(function (id) { return id.trim(); }).filter(function (id) { return !!id && (id.length >= 4 || /^[1-9][0-9]*$/.test(id)); });
                    ret = [];
                    _i = 0, ids_1 = ids;
                    _f.label = 1;
                case 1:
                    if (!(_i < ids_1.length)) return [3 /*break*/, 4];
                    id = ids_1[_i];
                    _b = (_a = ret).push;
                    _e = {};
                    _d = (_c = Asset).Url;
                    return [4 /*yield*/, url(id)];
                case 2:
                    _b.apply(_a, [(_e.url = _d.apply(_c, [_f.sent()]), _e.isBinary = isBinary, _e.label = label(id), _e)]);
                    _f.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/, ret];
            }
        });
    });
}
function getPdbeDownloadParams(src) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (src.name !== 'pdb' || src.params.provider.server.name !== 'pdbe')
                throw new Error('expected pdbe');
            return [2 /*return*/, src.params.provider.server.params.variant === 'updated'
                    ? getDownloadParams(src.params.provider.id, function (id) { return "https://www.ebi.ac.uk/pdbe/static/entry/".concat(id.toLowerCase(), "_updated.cif"); }, function (id) { return "PDBe: ".concat(id, " (updated cif)"); }, false)
                    : src.params.provider.server.params.variant === 'updated-bcif'
                        ? getDownloadParams(src.params.provider.id, function (id) { return "https://www.ebi.ac.uk/pdbe/entry-files/download/".concat(id.toLowerCase(), ".bcif"); }, function (id) { return "PDBe: ".concat(id, " (updated cif)"); }, true)
                        : getDownloadParams(src.params.provider.id, function (id) { return "https://www.ebi.ac.uk/pdbe/static/entry/".concat(id.toLowerCase(), ".cif"); }, function (id) { return "PDBe: ".concat(id, " (cif)"); }, false)];
        });
    });
}
function getPdbjDownloadParams(src) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (src.name !== 'pdb' || src.params.provider.server.name !== 'pdbj')
                throw new Error('expected pdbj');
            return [2 /*return*/, getDownloadParams(src.params.provider.id, function (id) { return "https://data.pdbjbk1.pdbj.org/pub/pdb/data/structures/divided/mmCIF/".concat(id.toLowerCase().substring(1, 3), "/").concat(id.toLowerCase(), ".cif"); }, function (id) { return "PDBj: ".concat(id, " (cif)"); }, false)];
        });
    });
}
function getRcsbDownloadParams(src) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (src.name !== 'pdb' || src.params.provider.server.name !== 'rcsb')
                throw new Error('expected rcsb');
            return [2 /*return*/, src.params.provider.server.params.encoding === 'cif'
                    ? getDownloadParams(src.params.provider.id, function (id) { return "https://files.rcsb.org/download/".concat(id.toUpperCase(), ".cif"); }, function (id) { return "RCSB PDB: ".concat(id, " (cif)"); }, false)
                    : getDownloadParams(src.params.provider.id, function (id) { return "https://models.rcsb.org/".concat(id.toUpperCase(), ".bcif"); }, function (id) { return "RCSB PDB: ".concat(id, " (bcif)"); }, true)];
        });
    });
}
export var UpdateTrajectory = StateAction.build({
    display: { name: 'Update Trajectory' },
    params: {
        action: PD.Select('advance', PD.arrayToOptions(['advance', 'reset'])),
        by: PD.Optional(PD.Numeric(1, { min: -1, max: 1, step: 1 }))
    }
})(function (_a) {
    var params = _a.params, state = _a.state;
    var models = state.selectQ(function (q) { return q.ofTransformer(StateTransforms.Model.ModelFromTrajectory); });
    var update = state.build();
    if (params.action === 'reset') {
        for (var _i = 0, models_1 = models; _i < models_1.length; _i++) {
            var m = models_1[_i];
            update.to(m).update({ modelIndex: 0 });
        }
    }
    else {
        var _loop_1 = function (m) {
            var parent_1 = StateSelection.findAncestorOfType(state.tree, state.cells, m.transform.ref, PluginStateObject.Molecule.Trajectory);
            if (!parent_1 || !parent_1.obj)
                return "continue";
            var traj = parent_1.obj;
            update.to(m).update(function (old) {
                var modelIndex = (old.modelIndex + params.by) % traj.data.frameCount;
                if (modelIndex < 0)
                    modelIndex += traj.data.frameCount;
                return { modelIndex: modelIndex };
            });
        };
        for (var _b = 0, models_2 = models; _b < models_2.length; _b++) {
            var m = models_2[_b];
            _loop_1(m);
        }
    }
    return state.updateTree(update);
});
export var EnableModelCustomProps = StateAction.build({
    display: { name: 'Custom Model Properties', description: 'Enable parameters for custom properties of the model.' },
    from: PluginStateObject.Molecule.Model,
    params: function (a, ctx) {
        return ctx.customModelProperties.getParams(a === null || a === void 0 ? void 0 : a.data);
    },
    isApplicable: function (a, t, ctx) {
        return t.transformer !== CustomModelProperties;
    }
})(function (_a, ctx) {
    var ref = _a.ref, params = _a.params;
    return ctx.builders.structure.insertModelProperties(ref, params);
});
export var EnableStructureCustomProps = StateAction.build({
    display: { name: 'Custom Structure Properties', description: 'Enable parameters for custom properties of the structure.' },
    from: PluginStateObject.Molecule.Structure,
    params: function (a, ctx) {
        return ctx.customStructureProperties.getParams(a === null || a === void 0 ? void 0 : a.data);
    },
    isApplicable: function (a, t, ctx) {
        return t.transformer !== CustomStructureProperties;
    }
})(function (_a, ctx) {
    var ref = _a.ref, params = _a.params;
    return ctx.builders.structure.insertStructureProperties(ref, params);
});
export var AddTrajectory = StateAction.build({
    display: { name: 'Add Trajectory', description: 'Add trajectory from existing model/topology and coordinates.' },
    from: PluginStateObject.Root,
    params: function (a, ctx) {
        var state = ctx.state.data;
        var models = __spreadArray(__spreadArray([], state.selectQ(function (q) { return q.rootsOfType(PluginStateObject.Molecule.Model); }), true), state.selectQ(function (q) { return q.rootsOfType(PluginStateObject.Molecule.Topology); }), true);
        var modelOptions = models.map(function (t) { return [t.transform.ref, t.obj.label]; });
        var coords = state.selectQ(function (q) { return q.rootsOfType(PluginStateObject.Molecule.Coordinates); });
        var coordOptions = coords.map(function (c) { return [c.transform.ref, c.obj.label]; });
        return {
            model: PD.Select(modelOptions.length ? modelOptions[0][0] : '', modelOptions),
            coordinates: PD.Select(coordOptions.length ? coordOptions[0][0] : '', coordOptions)
        };
    }
})(function (_a, ctx) {
    var params = _a.params, state = _a.state;
    return Task.create('Add Trajectory', function (taskCtx) {
        return state.transaction(function () { return __awaiter(void 0, void 0, void 0, function () {
            var dependsOn, model, structure;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dependsOn = [params.model, params.coordinates];
                        model = state.build().toRoot()
                            .apply(TrajectoryFromModelAndCoordinates, {
                            modelRef: params.model,
                            coordinatesRef: params.coordinates
                        }, { dependsOn: dependsOn })
                            .apply(StateTransforms.Model.ModelFromTrajectory, { modelIndex: 0 });
                        return [4 /*yield*/, state.updateTree(model).runInContext(taskCtx)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, ctx.builders.structure.createStructure(model.selector)];
                    case 2:
                        structure = _a.sent();
                        return [4 /*yield*/, ctx.builders.structure.representation.applyPreset(structure, 'auto')];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); }).runInContext(taskCtx);
    });
});
//# sourceMappingURL=structure.js.map