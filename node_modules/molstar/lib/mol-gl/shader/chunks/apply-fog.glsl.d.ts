export declare const apply_fog = "\nfloat preFogAlpha = gl_FragColor.a;\nif (uFog) {\n    float viewZ = depthToViewZ(uIsOrtho, fragmentDepth, uNear, uFar);\n    float fogFactor = smoothstep(uFogNear, uFogFar, abs(viewZ));\n    float fogAlpha = (1.0 - fogFactor) * gl_FragColor.a;\n    if (!uTransparentBackground) {\n        if (gl_FragColor.a < 1.0) {\n            // transparent objects are blended with background color\n            gl_FragColor.a = fogAlpha;\n        } else {\n            // mix opaque objects with background color\n            gl_FragColor.rgb = mix(gl_FragColor.rgb, uFogColor, fogFactor);\n        }\n    } else {\n        #if defined(dRenderVariant_colorDpoit) && !defined(dGeometryType_directVolume)\n            if (gl_FragColor.a < 1.0) {\n                // transparent objects are blended with background color\n                gl_FragColor.a = fogAlpha;\n            } else {\n                // opaque objects need to be pre-multiplied alpha\n                gl_FragColor.rgb *= fogAlpha;\n                gl_FragColor.a = fogAlpha;\n            }\n        #else\n            // pre-multiplied alpha expected for transparent background\n            gl_FragColor.rgb *= fogAlpha;\n            gl_FragColor.a = fogAlpha;\n        #endif\n    }\n} else if (uTransparentBackground) {\n    #if !defined(dRenderVariant_colorDpoit) && !defined(dGeometryType_directVolume)\n        // pre-multiplied alpha expected for transparent background\n        gl_FragColor.rgb *= gl_FragColor.a;\n    #endif\n}\n";
