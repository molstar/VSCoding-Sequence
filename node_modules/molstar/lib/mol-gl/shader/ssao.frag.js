/**
 * Copyright (c) 2019-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Áron Samuel Kovács <aron.kovacs@mail.muni.cz>
 */
export var ssao_frag = "\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n#include common\n\nuniform sampler2D tDepth;\nuniform vec2 uTexSize;\nuniform vec4 uBounds;\n\nuniform vec3 uSamples[dNSamples];\n\nuniform mat4 uProjection;\nuniform mat4 uInvProjection;\n\nuniform float uRadius;\nuniform float uBias;\n\nfloat smootherstep(float edge0, float edge1, float x) {\n    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat noise(const in vec2 coords) {\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt = dot(coords, vec2(a,b));\n    float sn = mod(dt, PI);\n    return abs(fract(sin(sn) * c)); // is abs necessary?\n}\n\nvec2 getNoiseVec2(const in vec2 coords) {\n    return vec2(noise(coords), noise(coords + vec2(PI, 2.71828)));\n}\n\nbool isBackground(const in float depth) {\n    return depth == 1.0;\n}\n\nbool outsideBounds(const in vec2 p) {\n    return p.x < uBounds.x || p.y < uBounds.y || p.x > uBounds.z || p.y > uBounds.w;\n}\n\nfloat getDepth(const in vec2 coords) {\n    if (outsideBounds(coords)) {\n        return 1.0;\n    } else {\n        #ifdef depthTextureSupport\n            return texture2D(tDepth, coords).r;\n        #else\n            return unpackRGBAToDepth(texture2D(tDepth, coords));\n        #endif\n    }\n}\n\nvec3 normalFromDepth(const in float depth, const in float depth1, const in float depth2, vec2 offset1, vec2 offset2) {\n    vec3 p1 = vec3(offset1, depth1 - depth);\n    vec3 p2 = vec3(offset2, depth2 - depth);\n\n    vec3 normal = cross(p1, p2);\n    normal.z = -normal.z;\n\n    return normalize(normal);\n}\n\n// StarCraft II Ambient Occlusion by [Filion and McNaughton 2008]\nvoid main(void) {\n    vec2 invTexSize = 1.0 / uTexSize;\n    vec2 selfCoords = gl_FragCoord.xy * invTexSize;\n\n    float selfDepth = getDepth(selfCoords);\n    vec2 selfPackedDepth = packUnitIntervalToRG(selfDepth);\n\n    if (isBackground(selfDepth)) {\n        gl_FragColor = vec4(packUnitIntervalToRG(0.0), selfPackedDepth);\n        return;\n    }\n\n    vec2 offset1 = vec2(0.0, invTexSize.y);\n    vec2 offset2 = vec2(invTexSize.x, 0.0);\n\n    float selfDepth1 = getDepth(selfCoords + offset1);\n    float selfDepth2 = getDepth(selfCoords + offset2);\n\n    vec3 selfViewNormal = normalFromDepth(selfDepth, selfDepth1, selfDepth2, offset1, offset2);\n    vec3 selfViewPos = screenSpaceToViewSpace(vec3(selfCoords, selfDepth), uInvProjection);\n\n    vec3 randomVec = normalize(vec3(getNoiseVec2(selfCoords) * 2.0 - 1.0, 0.0));\n\n    vec3 tangent = normalize(randomVec - selfViewNormal * dot(randomVec, selfViewNormal));\n    vec3 bitangent = cross(selfViewNormal, tangent);\n    mat3 TBN = mat3(tangent, bitangent, selfViewNormal);\n\n    float occlusion = 0.0;\n    for(int i = 0; i < dNSamples; i++){\n        vec3 sampleViewPos = TBN * uSamples[i];\n        sampleViewPos = selfViewPos + sampleViewPos * uRadius;\n\n        vec4 offset = vec4(sampleViewPos, 1.0);\n        offset = uProjection * offset;\n        offset.xyz = (offset.xyz / offset.w) * 0.5 + 0.5;\n\n        float sampleViewZ = screenSpaceToViewSpace(vec3(offset.xy, getDepth(offset.xy)), uInvProjection).z;\n\n        occlusion += step(sampleViewPos.z + 0.025, sampleViewZ) * smootherstep(0.0, 1.0, uRadius / abs(selfViewPos.z - sampleViewZ));\n    }\n    occlusion = 1.0 - (uBias * occlusion / float(dNSamples));\n\n    vec2 packedOcclusion = packUnitIntervalToRG(occlusion);\n\n    gl_FragColor = vec4(packedOcclusion, selfPackedDepth);\n}\n";
