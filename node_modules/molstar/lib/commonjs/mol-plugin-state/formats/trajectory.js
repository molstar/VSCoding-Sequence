"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuiltInTrajectoryFormats = exports.Mol2Provider = exports.SdfProvider = exports.MolProvider = exports.GroProvider = exports.XyzProvider = exports.PdbqtProvider = exports.PdbProvider = exports.CifCoreProvider = exports.MmcifProvider = exports.TrajectoryFormatCategory = void 0;
var tslib_1 = require("tslib");
var transforms_1 = require("../transforms");
var provider_1 = require("./provider");
exports.TrajectoryFormatCategory = 'Trajectory';
function defaultVisuals(plugin, data) {
    return plugin.builders.structure.hierarchy.applyPreset(data.trajectory, 'default');
}
exports.MmcifProvider = {
    label: 'mmCIF',
    description: 'mmCIF',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['cif', 'mmcif', 'mcif'],
    binaryExtensions: ['bcif'],
    isApplicable: function (info, data) {
        if (info.ext === 'mmcif' || info.ext === 'mcif')
            return true;
        // assume undetermined cif/bcif files are mmCIF
        if (info.ext === 'cif' || info.ext === 'bcif')
            return (0, provider_1.guessCifVariant)(info, data) === -1;
        return false;
    },
    parse: function (plugin, data, params) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var state, cif, trajectory;
        var _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    state = plugin.state.data;
                    cif = state.build().to(data)
                        .apply(transforms_1.StateTransforms.Data.ParseCif, void 0, { state: { isGhost: true } });
                    return [4 /*yield*/, cif
                            .apply(transforms_1.StateTransforms.Model.TrajectoryFromMmCif, void 0, { tags: params === null || params === void 0 ? void 0 : params.trajectoryTags })
                            .commit({ revertOnError: true })];
                case 1:
                    trajectory = _c.sent();
                    if ((((_b = (_a = cif.selector.cell) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data.blocks.length) || 0) > 1) {
                        plugin.state.data.updateCellState(cif.ref, { isGhost: false });
                    }
                    return [2 /*return*/, { trajectory: trajectory }];
            }
        });
    }); },
    visuals: defaultVisuals
};
exports.CifCoreProvider = {
    label: 'cifCore',
    description: 'CIF Core',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['cif'],
    isApplicable: function (info, data) {
        if (info.ext === 'cif')
            return (0, provider_1.guessCifVariant)(info, data) === 'coreCif';
        return false;
    },
    parse: function (plugin, data, params) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var state, cif, trajectory;
        var _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    state = plugin.state.data;
                    cif = state.build().to(data)
                        .apply(transforms_1.StateTransforms.Data.ParseCif, void 0, { state: { isGhost: true } });
                    return [4 /*yield*/, cif
                            .apply(transforms_1.StateTransforms.Model.TrajectoryFromCifCore, void 0, { tags: params === null || params === void 0 ? void 0 : params.trajectoryTags })
                            .commit({ revertOnError: true })];
                case 1:
                    trajectory = _c.sent();
                    if ((((_b = (_a = cif.selector.cell) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data.blocks.length) || 0) > 1) {
                        plugin.state.data.updateCellState(cif.ref, { isGhost: false });
                    }
                    return [2 /*return*/, { trajectory: trajectory }];
            }
        });
    }); },
    visuals: defaultVisuals
};
function directTrajectory(transformer, transformerParams) {
    var _this = this;
    return function (plugin, data, params) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state, trajectory;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    state = plugin.state.data;
                    return [4 /*yield*/, state.build().to(data)
                            .apply(transformer, transformerParams, { tags: params === null || params === void 0 ? void 0 : params.trajectoryTags })
                            .commit({ revertOnError: true })];
                case 1:
                    trajectory = _a.sent();
                    return [2 /*return*/, { trajectory: trajectory }];
            }
        });
    }); };
}
exports.PdbProvider = {
    label: 'PDB',
    description: 'PDB',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['pdb', 'ent'],
    parse: directTrajectory(transforms_1.StateTransforms.Model.TrajectoryFromPDB),
    visuals: defaultVisuals
};
exports.PdbqtProvider = {
    label: 'PDBQT',
    description: 'PDBQT',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['pdbqt'],
    parse: directTrajectory(transforms_1.StateTransforms.Model.TrajectoryFromPDB, { isPdbqt: true }),
    visuals: defaultVisuals
};
exports.XyzProvider = {
    label: 'XYZ',
    description: 'XYZ',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['xyz'],
    parse: directTrajectory(transforms_1.StateTransforms.Model.TrajectoryFromXYZ),
    visuals: defaultVisuals
};
exports.GroProvider = {
    label: 'GRO',
    description: 'GRO',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['gro'],
    binaryExtensions: [],
    parse: directTrajectory(transforms_1.StateTransforms.Model.TrajectoryFromGRO),
    visuals: defaultVisuals
};
exports.MolProvider = {
    label: 'MOL',
    description: 'MOL',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['mol'],
    parse: directTrajectory(transforms_1.StateTransforms.Model.TrajectoryFromMOL),
    visuals: defaultVisuals
};
exports.SdfProvider = {
    label: 'SDF',
    description: 'SDF',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['sdf', 'sd'],
    parse: directTrajectory(transforms_1.StateTransforms.Model.TrajectoryFromSDF),
    visuals: defaultVisuals
};
exports.Mol2Provider = {
    label: 'MOL2',
    description: 'MOL2',
    category: exports.TrajectoryFormatCategory,
    stringExtensions: ['mol2'],
    parse: directTrajectory(transforms_1.StateTransforms.Model.TrajectoryFromMOL2),
    visuals: defaultVisuals
};
exports.BuiltInTrajectoryFormats = [
    ['mmcif', exports.MmcifProvider],
    ['cifCore', exports.CifCoreProvider],
    ['pdb', exports.PdbProvider],
    ['pdbqt', exports.PdbqtProvider],
    ['gro', exports.GroProvider],
    ['xyz', exports.XyzProvider],
    ['mol', exports.MolProvider],
    ['sdf', exports.SdfProvider],
    ['mol2', exports.Mol2Provider],
];
