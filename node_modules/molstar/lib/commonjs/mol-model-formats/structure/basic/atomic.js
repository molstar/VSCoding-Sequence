"use strict";
/**
 * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAtomicHierarchyAndConformation = void 0;
var tslib_1 = require("tslib");
var db_1 = require("../../../mol-data/db");
var int_1 = require("../../../mol-data/int");
var schema_1 = require("../../../mol-io/reader/cif/schema");
var geometry_1 = require("../../../mol-math/geometry");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var atom_site_operator_mapping_1 = require("../../../mol-model/structure/export/categories/atom_site_operator_mapping");
var atomic_1 = require("../../../mol-model/structure/model/properties/atomic");
var atomic_derived_1 = require("../../../mol-model/structure/model/properties/utils/atomic-derived");
var atomic_index_1 = require("../../../mol-model/structure/model/properties/utils/atomic-index");
var types_1 = require("../../../mol-model/structure/model/types");
var uuid_1 = require("../../../mol-util/uuid");
var mmcif_1 = require("../mmcif");
function findHierarchyOffsets(atom_site) {
    if (atom_site._rowCount === 0)
        return { residues: [], chains: [] };
    var start = 0, end = atom_site._rowCount;
    var residues = [start], chains = [start];
    var label_entity_id = atom_site.label_entity_id, label_asym_id = atom_site.label_asym_id, label_seq_id = atom_site.label_seq_id, auth_seq_id = atom_site.auth_seq_id, pdbx_PDB_ins_code = atom_site.pdbx_PDB_ins_code;
    for (var i = start + 1; i < end; i++) {
        var newChain = !label_entity_id.areValuesEqual(i - 1, i) || !label_asym_id.areValuesEqual(i - 1, i);
        var newResidue = newChain
            || !label_seq_id.areValuesEqual(i - 1, i)
            || !auth_seq_id.areValuesEqual(i - 1, i)
            || !pdbx_PDB_ins_code.areValuesEqual(i - 1, i);
        // not checking label_comp_id to allow for MICROHETEROGENEITY
        if (newResidue)
            residues[residues.length] = i;
        if (newChain)
            chains[chains.length] = i;
    }
    return { residues: residues, chains: chains };
}
function substUndefinedColumn(table, a, b) {
    if (!table[a].isDefined) {
        table[a] = table[b];
    }
    if (!table[b].isDefined) {
        table[b] = table[a];
    }
}
function createHierarchyData(atom_site, sourceIndex, offsets) {
    var atoms = db_1.Table.ofColumns(atomic_1.AtomsSchema, {
        type_symbol: db_1.Column.ofArray({ array: db_1.Column.mapToArray(atom_site.type_symbol, types_1.ElementSymbol), schema: db_1.Column.Schema.Aliased(db_1.Column.Schema.str) }),
        label_atom_id: atom_site.label_atom_id,
        auth_atom_id: atom_site.auth_atom_id,
        label_alt_id: atom_site.label_alt_id,
        label_comp_id: atom_site.label_comp_id,
        auth_comp_id: atom_site.auth_comp_id,
        pdbx_formal_charge: atom_site.pdbx_formal_charge
    });
    var residues = db_1.Table.view(atom_site, atomic_1.ResiduesSchema, offsets.residues);
    var chains = db_1.Table.view(atom_site, atomic_1.ChainsSchema, offsets.chains);
    if (!residues.label_seq_id.isDefined) {
        var seqIds = new Int32Array(residues.label_seq_id.rowCount);
        var residueOffsets = offsets.residues, chainOffsets = offsets.chains;
        var cI = 0;
        var seqId = 0;
        for (var i = 0, il = seqIds.length; i < il; ++i) {
            if (residueOffsets[i] >= chainOffsets[cI + 1]) {
                cI += 1;
                seqId = 0;
            }
            seqIds[i] = ++seqId; // start id on one
        }
        residues.label_seq_id = db_1.Column.ofIntArray(seqIds);
    }
    // Optimize the numeric columns
    db_1.Table.columnToArray(residues, 'label_seq_id', Int32Array);
    db_1.Table.columnToArray(residues, 'auth_seq_id', Int32Array);
    // Fix possibly missing auth_/label_ columns
    substUndefinedColumn(atoms, 'label_atom_id', 'auth_atom_id');
    substUndefinedColumn(atoms, 'label_comp_id', 'auth_comp_id');
    substUndefinedColumn(residues, 'label_seq_id', 'auth_seq_id');
    substUndefinedColumn(chains, 'label_asym_id', 'auth_asym_id');
    return { atoms: atoms, residues: residues, chains: chains, atomSourceIndex: sourceIndex };
}
function getConformation(atom_site) {
    return {
        id: uuid_1.UUID.create22(),
        atomId: atom_site.id,
        occupancy: atom_site.occupancy.isDefined ? atom_site.occupancy : db_1.Column.ofConst(1, atom_site._rowCount, db_1.Column.Schema.float),
        B_iso_or_equiv: atom_site.B_iso_or_equiv,
        xyzDefined: atom_site.Cartn_x.isDefined && atom_site.Cartn_y.isDefined && atom_site.Cartn_z.isDefined,
        x: atom_site.Cartn_x.toArray({ array: Float32Array }),
        y: atom_site.Cartn_y.toArray({ array: Float32Array }),
        z: atom_site.Cartn_z.toArray({ array: Float32Array }),
    };
}
function isHierarchyDataEqual(a, b) {
    return db_1.Table.areEqual(a.chains, b.chains)
        && db_1.Table.areEqual(a.residues, b.residues)
        && db_1.Table.areEqual(a.atoms, b.atoms);
}
function createChainOperatorMappingAndSubstituteNames(hierarchy, format) {
    var mapping = new Map();
    if (!mmcif_1.MmcifFormat.is(format))
        return mapping;
    var entries = (0, schema_1.toDatabase)(atom_site_operator_mapping_1.AtomSiteOperatorMappingSchema, format.data.frame).molstar_atom_site_operator_mapping;
    if (entries._rowCount === 0)
        return mapping;
    var labelMap = new Map();
    var authMap = new Map();
    for (var i = 0; i < entries._rowCount; i++) {
        var assembly = entries.assembly_operator_id.valueKind(i) === 0 /* Present */
            ? { id: entries.assembly_id.value(i), operList: [], operId: entries.assembly_operator_id.value(i) }
            : void 0;
        var operator = geometry_1.SymmetryOperator.create(entries.operator_name.value(i), linear_algebra_1.Mat4.identity(), {
            assembly: assembly,
            spgrOp: entries.symmetry_operator_index.valueKind(i) === 0 /* Present */ ? entries.symmetry_operator_index.value(i) : void 0,
            hkl: linear_algebra_1.Vec3.ofArray(entries.symmetry_hkl.value(i)),
            ncsId: entries.ncs_id.value(i)
        });
        var suffix = entries.suffix.value(i);
        var label = entries.label_asym_id.value(i);
        labelMap.set("".concat(label).concat(suffix), { name: label, operator: operator });
        var auth = entries.auth_asym_id.value(i);
        authMap.set("".concat(auth).concat(suffix), auth);
    }
    var _a = hierarchy.chains, label_asym_id = _a.label_asym_id, auth_asym_id = _a.auth_asym_id;
    var mappedLabel = new Array(label_asym_id.rowCount);
    var mappedAuth = new Array(label_asym_id.rowCount);
    for (var i = 0; i < label_asym_id.rowCount; i++) {
        var label = label_asym_id.value(i), auth = auth_asym_id.value(i);
        if (!labelMap.has(label)) {
            mappedLabel[i] = label;
            mappedAuth[i] = auth;
            continue;
        }
        var _b = labelMap.get(label), name_1 = _b.name, operator = _b.operator;
        mapping.set(i, operator);
        mappedLabel[i] = name_1;
        mappedAuth[i] = authMap.get(auth) || auth;
    }
    hierarchy.chains.label_asym_id = db_1.Column.ofArray({ array: mappedLabel, valueKind: hierarchy.chains.label_asym_id.valueKind, schema: hierarchy.chains.label_asym_id.schema });
    hierarchy.chains.auth_asym_id = db_1.Column.ofArray({ array: mappedAuth, valueKind: hierarchy.chains.auth_asym_id.valueKind, schema: hierarchy.chains.auth_asym_id.schema });
    return mapping;
}
function getAtomicHierarchy(atom_site, sourceIndex, entities, chemicalComponentMap, format, previous) {
    var hierarchyOffsets = findHierarchyOffsets(atom_site);
    var hierarchyData = createHierarchyData(atom_site, sourceIndex, hierarchyOffsets);
    var chainOperatorMapping = createChainOperatorMappingAndSubstituteNames(hierarchyData, format);
    if (previous && isHierarchyDataEqual(previous.atomicHierarchy, hierarchyData)) {
        return {
            sameAsPrevious: true,
            hierarchy: previous.atomicHierarchy,
            chainOperatorMapping: chainOperatorMapping
        };
    }
    var hierarchySegments = {
        residueAtomSegments: int_1.Segmentation.ofOffsets(hierarchyOffsets.residues, int_1.Interval.ofBounds(0, atom_site._rowCount)),
        chainAtomSegments: int_1.Segmentation.ofOffsets(hierarchyOffsets.chains, int_1.Interval.ofBounds(0, atom_site._rowCount)),
    };
    var index = (0, atomic_index_1.getAtomicIndex)(hierarchyData, entities, hierarchySegments);
    var derived = (0, atomic_derived_1.getAtomicDerivedData)(hierarchyData, hierarchySegments, index, chemicalComponentMap);
    var hierarchy = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, hierarchyData), hierarchySegments), { index: index, derived: derived });
    return { sameAsPrevious: false, hierarchy: hierarchy, chainOperatorMapping: chainOperatorMapping };
}
function getAtomicHierarchyAndConformation(atom_site, sourceIndex, entities, chemicalComponentMap, format, previous) {
    var _a = getAtomicHierarchy(atom_site, sourceIndex, entities, chemicalComponentMap, format, previous), sameAsPrevious = _a.sameAsPrevious, hierarchy = _a.hierarchy, chainOperatorMapping = _a.chainOperatorMapping;
    var conformation = getConformation(atom_site);
    return { sameAsPrevious: sameAsPrevious, hierarchy: hierarchy, conformation: conformation, chainOperatorMapping: chainOperatorMapping };
}
exports.getAtomicHierarchyAndConformation = getAtomicHierarchyAndConformation;
//# sourceMappingURL=atomic.js.map