"use strict";
/**
 * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorScale = exports.DefaultColorScaleProps = void 0;
var tslib_1 = require("tslib");
var color_1 = require("./color");
var lists_1 = require("./lists");
var mol_util_1 = require("../../mol-util");
var legend_1 = require("../legend");
var int_1 = require("../../mol-data/int");
var interpolate_1 = require("../../mol-math/interpolate");
exports.DefaultColorScaleProps = {
    domain: [0, 1],
    reverse: false,
    listOrName: 'red-yellow-blue',
    minLabel: '',
    maxLabel: '',
};
var ColorScale;
(function (ColorScale) {
    function create(props) {
        var _a = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, exports.DefaultColorScaleProps), props), domain = _a.domain, reverse = _a.reverse, listOrName = _a.listOrName;
        var list = typeof listOrName === 'string' ? (0, lists_1.getColorListFromName)(listOrName).list : listOrName;
        var colors = reverse ? list.slice().reverse() : list;
        var count1 = colors.length - 1;
        var diff = 0, min = 0, max = 0;
        function setDomain(_min, _max) {
            min = _min;
            max = _max;
            diff = (max - min) || 1;
        }
        setDomain(domain[0], domain[1]);
        var minLabel = (0, mol_util_1.defaults)(props.minLabel, min.toString());
        var maxLabel = (0, mol_util_1.defaults)(props.maxLabel, max.toString());
        var color;
        var hasOffsets = colors.every(function (c) { return Array.isArray(c); });
        if (hasOffsets) {
            var sorted = (0, tslib_1.__spreadArray)([], colors, true);
            sorted.sort(function (a, b) { return a[1] - b[1]; });
            var src_1 = sorted.map(function (c) { return c[0]; });
            var off_1 = int_1.SortedArray.ofSortedArray(sorted.map(function (c) { return c[1]; }));
            var max_1 = src_1.length - 1;
            color = function (v) {
                var t = (0, interpolate_1.clamp)((v - min) / diff, 0, 1);
                var i = int_1.SortedArray.findPredecessorIndex(off_1, t);
                if (i === 0) {
                    return src_1[min];
                }
                else if (i > max_1) {
                    return src_1[max_1];
                }
                var o1 = off_1[i - 1], o2 = off_1[i];
                var t1 = (0, interpolate_1.clamp)((t - o1) / (o2 - o1), 0, 1); // TODO: cache the deltas?
                return color_1.Color.interpolate(src_1[i - 1], src_1[i], t1);
            };
        }
        else {
            color = function (value) {
                var t = Math.min(colors.length - 1, Math.max(0, ((value - min) / diff) * count1));
                var tf = Math.floor(t);
                var c1 = colors[tf];
                var c2 = colors[Math.ceil(t)];
                return color_1.Color.interpolate(c1, c2, t - tf);
            };
        }
        return {
            color: color,
            colorToArray: function (value, array, offset) {
                color_1.Color.toArray(color(value), array, offset);
            },
            normalizedColorToArray: function (value, array, offset) {
                color_1.Color.toArrayNormalized(color(value), array, offset);
            },
            setDomain: setDomain,
            get legend() { return (0, legend_1.ScaleLegend)(minLabel, maxLabel, colors); }
        };
    }
    ColorScale.create = create;
})(ColorScale = exports.ColorScale || (exports.ColorScale = {}));
//# sourceMappingURL=scale.js.map