"use strict";
/**
 * Copyright (c) 2018-2019 Mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraTransitionManager = void 0;
var camera_1 = require("../camera");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var interpolate_1 = require("../../mol-math/interpolate");
var CameraTransitionManager = /** @class */ (function () {
    function CameraTransitionManager(camera) {
        this.camera = camera;
        this.t = 0;
        this.func = CameraTransitionManager.defaultTransition;
        this.start = 0;
        this.inTransition = false;
        this.durationMs = 0;
        this._source = camera_1.Camera.createDefaultSnapshot();
        this._target = camera_1.Camera.createDefaultSnapshot();
        this._current = camera_1.Camera.createDefaultSnapshot();
    }
    Object.defineProperty(CameraTransitionManager.prototype, "source", {
        get: function () { return this._source; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CameraTransitionManager.prototype, "target", {
        get: function () { return this._target; },
        enumerable: false,
        configurable: true
    });
    CameraTransitionManager.prototype.apply = function (to, durationMs, transition) {
        if (durationMs === void 0) { durationMs = 0; }
        if (!this.inTransition || durationMs > 0) {
            camera_1.Camera.copySnapshot(this._source, this.camera.state);
        }
        if (!this.inTransition) {
            camera_1.Camera.copySnapshot(this._target, this.camera.state);
        }
        camera_1.Camera.copySnapshot(this._target, to);
        if (this._target.radius > this._target.radiusMax) {
            this._target.radius = this._target.radiusMax;
        }
        if (this._target.radius < 0.01)
            this._target.radius = 0.01;
        if (this._target.radiusMax < 0.01)
            this._target.radiusMax = 0.01;
        if (!this.inTransition && durationMs <= 0 || (typeof to.mode !== 'undefined' && to.mode !== this.camera.state.mode)) {
            this.finish(this._target);
            return;
        }
        this.inTransition = true;
        this.func = transition || CameraTransitionManager.defaultTransition;
        if (!this.inTransition || durationMs > 0) {
            this.start = this.t;
            this.durationMs = durationMs;
        }
    };
    CameraTransitionManager.prototype.tick = function (t) {
        this.t = t;
        this.update();
    };
    CameraTransitionManager.prototype.finish = function (to) {
        camera_1.Camera.copySnapshot(this.camera.state, to);
        this.inTransition = false;
    };
    CameraTransitionManager.prototype.update = function () {
        if (!this.inTransition)
            return;
        var normalized = Math.min((this.t - this.start) / this.durationMs, 1);
        if (normalized === 1) {
            this.finish(this._target);
            return;
        }
        this.func(this._current, normalized, this._source, this._target);
        camera_1.Camera.copySnapshot(this.camera.state, this._current);
    };
    return CameraTransitionManager;
}());
exports.CameraTransitionManager = CameraTransitionManager;
(function (CameraTransitionManager) {
    var _rot = linear_algebra_1.Quat.identity();
    function defaultTransition(out, t, source, target) {
        camera_1.Camera.copySnapshot(out, target);
        // Rotate up
        linear_algebra_1.Quat.slerp(_rot, linear_algebra_1.Quat.Identity, linear_algebra_1.Quat.rotationTo(_rot, source.up, target.up), t);
        linear_algebra_1.Vec3.transformQuat(out.up, source.up, _rot);
        // Lerp target, position & radius
        linear_algebra_1.Vec3.lerp(out.target, source.target, target.target, t);
        linear_algebra_1.Vec3.lerp(out.position, source.position, target.position, t);
        out.radius = (0, interpolate_1.lerp)(source.radius, target.radius, t);
        // TODO take change of `clipFar` into account
        out.radiusMax = (0, interpolate_1.lerp)(source.radiusMax, target.radiusMax, t);
        // Lerp fov & fog
        out.fov = (0, interpolate_1.lerp)(source.fov, target.fov, t);
        out.fog = (0, interpolate_1.lerp)(source.fog, target.fog, t);
    }
    CameraTransitionManager.defaultTransition = defaultTransition;
})(CameraTransitionManager || (CameraTransitionManager = {}));
exports.CameraTransitionManager = CameraTransitionManager;
