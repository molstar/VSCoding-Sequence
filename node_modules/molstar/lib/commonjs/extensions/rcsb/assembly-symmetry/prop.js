"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssemblySymmetryProvider = exports.AssemblySymmetryParams = exports.AssemblySymmetryDataProvider = exports.AssemblySymmetryDataParams = exports.getSymmetrySelectParam = exports.AssemblySymmetry = exports.isBiologicalAssembly = void 0;
var tslib_1 = require("tslib");
var symmetry_gql_1 = require("../graphql/symmetry.gql");
var param_definition_1 = require("../../../mol-util/param-definition");
var structure_1 = require("../../../mol-model/structure");
var db_1 = require("../../../mol-data/db");
var graphql_client_1 = require("../../../mol-util/graphql-client");
var custom_structure_property_1 = require("../../../mol-model-props/common/custom-structure-property");
var mmcif_1 = require("../../../mol-model-formats/structure/mmcif");
var set_1 = require("../../../mol-util/set");
var builder_1 = require("../../../mol-script/language/builder");
var compiler_1 = require("../../../mol-script/runtime/query/compiler");
var custom_property_1 = require("../../../mol-model/custom-property");
var BiologicalAssemblyNames = new Set([
    'author_and_software_defined_assembly',
    'author_defined_assembly',
    'complete icosahedral assembly',
    'complete point assembly',
    'representative helical assembly',
    'software_defined_assembly'
]);
function isBiologicalAssembly(structure) {
    var _a;
    if (!mmcif_1.MmcifFormat.is(structure.models[0].sourceData))
        return false;
    var mmcif = structure.models[0].sourceData.data.db;
    if (!mmcif.pdbx_struct_assembly.details.isDefined)
        return false;
    var id = ((_a = structure.units[0].conformation.operator.assembly) === null || _a === void 0 ? void 0 : _a.id) || '';
    if (id === '')
        return true;
    var indices = db_1.Column.indicesOf(mmcif.pdbx_struct_assembly.id, function (e) { return e === id; });
    if (indices.length !== 1)
        return false;
    var details = mmcif.pdbx_struct_assembly.details.value(indices[0]);
    return BiologicalAssemblyNames.has(details);
}
exports.isBiologicalAssembly = isBiologicalAssembly;
var AssemblySymmetry;
(function (AssemblySymmetry) {
    var Tag;
    (function (Tag) {
        Tag["Cluster"] = "rcsb-assembly-symmetry-cluster";
        Tag["Representation"] = "rcsb-assembly-symmetry-3d";
    })(Tag = AssemblySymmetry.Tag || (AssemblySymmetry.Tag = {}));
    AssemblySymmetry.DefaultServerUrl = 'https://data.rcsb.org/graphql';
    function isApplicable(structure) {
        return (!!structure && structure.models.length === 1 &&
            structure_1.Model.hasPdbId(structure.models[0]) &&
            isBiologicalAssembly(structure));
    }
    AssemblySymmetry.isApplicable = isApplicable;
    function fetch(ctx, structure, props) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var client, variables, result, value;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!isApplicable(structure))
                            return [2 /*return*/, { value: [] }];
                        client = new graphql_client_1.GraphQLClient(props.serverUrl, ctx.assetManager);
                        variables = {
                            assembly_id: ((_a = structure.units[0].conformation.operator.assembly) === null || _a === void 0 ? void 0 : _a.id) || '',
                            entry_id: structure.units[0].model.entryId
                        };
                        return [4 /*yield*/, client.request(ctx.runtime, symmetry_gql_1.symmetry_gql, variables)];
                    case 1:
                        result = _c.sent();
                        value = [];
                        if (!((_b = result.data.assembly) === null || _b === void 0 ? void 0 : _b.rcsb_struct_symmetry)) {
                            console.error('expected `rcsb_struct_symmetry` field');
                        }
                        else {
                            value = result.data.assembly.rcsb_struct_symmetry;
                        }
                        return [2 /*return*/, { value: value, assets: [result] }];
                }
            });
        });
    }
    AssemblySymmetry.fetch = fetch;
    /** Returns the index of the first non C1 symmetry or -1 */
    function firstNonC1(assemblySymmetryData) {
        for (var i = 0, il = assemblySymmetryData.length; i < il; ++i) {
            if (assemblySymmetryData[i].symbol !== 'C1')
                return i;
        }
        return -1;
    }
    AssemblySymmetry.firstNonC1 = firstNonC1;
    function isRotationAxes(x) {
        return !!x && x.length > 0;
    }
    AssemblySymmetry.isRotationAxes = isRotationAxes;
    function getAsymIds(assemblySymmetry) {
        var asymIds = new Set();
        for (var _i = 0, _a = assemblySymmetry.clusters; _i < _a.length; _i++) {
            var c = _a[_i];
            if (!(c === null || c === void 0 ? void 0 : c.members))
                continue;
            for (var _b = 0, _c = c.members; _b < _c.length; _b++) {
                var m = _c[_b];
                if (m === null || m === void 0 ? void 0 : m.asym_id)
                    asymIds.add(m.asym_id);
            }
        }
        return set_1.SetUtils.toArray(asymIds);
    }
    AssemblySymmetry.getAsymIds = getAsymIds;
    function getAsymIdsStructure(structure, asymIds) {
        var query = builder_1.MolScriptBuilder.struct.modifier.union([
            builder_1.MolScriptBuilder.struct.generator.atomGroups({
                'chain-test': builder_1.MolScriptBuilder.core.set.has([builder_1.MolScriptBuilder.set.apply(builder_1.MolScriptBuilder, asymIds), builder_1.MolScriptBuilder.ammp('label_asym_id')])
            })
        ]);
        var compiled = (0, compiler_1.compile)(query);
        var result = compiled(new structure_1.QueryContext(structure));
        return structure_1.StructureSelection.unionStructure(result);
    }
    /** Returns structure limited to all cluster member chains */
    function getStructure(structure, assemblySymmetry) {
        var asymIds = AssemblySymmetry.getAsymIds(assemblySymmetry);
        return asymIds.length > 0 ? getAsymIdsStructure(structure, asymIds) : structure;
    }
    AssemblySymmetry.getStructure = getStructure;
})(AssemblySymmetry = exports.AssemblySymmetry || (exports.AssemblySymmetry = {}));
function getSymmetrySelectParam(structure) {
    var param = param_definition_1.ParamDefinition.Select(0, [[0, 'First Symmetry']]);
    if (structure) {
        var assemblySymmetryData = exports.AssemblySymmetryDataProvider.get(structure).value;
        if (assemblySymmetryData) {
            var options = [
                [-1, 'Off']
            ];
            for (var i = 0, il = assemblySymmetryData.length; i < il; ++i) {
                var _a = assemblySymmetryData[i], symbol = _a.symbol, kind = _a.kind;
                if (symbol !== 'C1') {
                    options.push([i, "".concat(i + 1, ": ").concat(symbol, " ").concat(kind)]);
                }
            }
            if (options.length > 1) {
                param.options = options;
                param.defaultValue = options[1][0];
            }
            else {
                options.length = 0;
            }
        }
    }
    return param;
}
exports.getSymmetrySelectParam = getSymmetrySelectParam;
//
exports.AssemblySymmetryDataParams = {
    serverUrl: param_definition_1.ParamDefinition.Text(AssemblySymmetry.DefaultServerUrl, { description: 'GraphQL endpoint URL' })
};
exports.AssemblySymmetryDataProvider = custom_structure_property_1.CustomStructureProperty.createProvider({
    label: 'Assembly Symmetry Data',
    descriptor: (0, custom_property_1.CustomPropertyDescriptor)({
        name: 'rcsb_struct_symmetry_data',
        // TODO `cifExport` and `symbol`
    }),
    type: 'root',
    defaultParams: exports.AssemblySymmetryDataParams,
    getParams: function (data) { return exports.AssemblySymmetryDataParams; },
    isApplicable: function (data) { return AssemblySymmetry.isApplicable(data); },
    obtain: function (ctx, data, props) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var p;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    p = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(exports.AssemblySymmetryDataParams)), props);
                    return [4 /*yield*/, AssemblySymmetry.fetch(ctx, data, p)];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    }); }
});
//
function getAssemblySymmetryParams(data) {
    return tslib_1.__assign(tslib_1.__assign({}, exports.AssemblySymmetryDataParams), { symmetryIndex: getSymmetrySelectParam(data) });
}
exports.AssemblySymmetryParams = getAssemblySymmetryParams();
exports.AssemblySymmetryProvider = custom_structure_property_1.CustomStructureProperty.createProvider({
    label: 'Assembly Symmetry',
    descriptor: (0, custom_property_1.CustomPropertyDescriptor)({
        name: 'rcsb_struct_symmetry',
        // TODO `cifExport` and `symbol`
    }),
    type: 'root',
    defaultParams: exports.AssemblySymmetryParams,
    getParams: getAssemblySymmetryParams,
    isApplicable: function (data) { return AssemblySymmetry.isApplicable(data); },
    obtain: function (ctx, data, props) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var p, assemblySymmetryData, assemblySymmetry;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    p = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(getAssemblySymmetryParams(data))), props);
                    return [4 /*yield*/, exports.AssemblySymmetryDataProvider.attach(ctx, data, p)];
                case 1:
                    _a.sent();
                    assemblySymmetryData = exports.AssemblySymmetryDataProvider.get(data).value;
                    assemblySymmetry = assemblySymmetryData === null || assemblySymmetryData === void 0 ? void 0 : assemblySymmetryData[p.symmetryIndex];
                    if (!assemblySymmetry)
                        new Error("No assembly symmetry found for index ".concat(p.symmetryIndex));
                    return [2 /*return*/, { value: assemblySymmetry }];
            }
        });
    }); }
});
