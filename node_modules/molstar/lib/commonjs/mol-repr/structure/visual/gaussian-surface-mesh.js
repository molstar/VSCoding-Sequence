"use strict";
/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructureGaussianSurfaceTextureMeshVisual = exports.GaussianSurfaceTextureMeshVisual = exports.StructureGaussianSurfaceMeshVisual = exports.GaussianSurfaceMeshVisual = exports.StructureGaussianSurfaceVisual = exports.GaussianSurfaceVisual = exports.StructureGaussianSurfaceMeshParams = exports.GaussianSurfaceMeshParams = void 0;
var tslib_1 = require("tslib");
var param_definition_1 = require("../../../mol-util/param-definition");
var units_visual_1 = require("../units-visual");
var gaussian_1 = require("./util/gaussian");
var mesh_1 = require("../../../mol-geo/geometry/mesh/mesh");
var algorithm_1 = require("../../../mol-geo/util/marching-cubes/algorithm");
var element_1 = require("./util/element");
var texture_mesh_1 = require("../../../mol-geo/geometry/texture-mesh/texture-mesh");
var isosurface_1 = require("../../../mol-gl/compute/marching-cubes/isosurface");
var geometry_1 = require("../../../mol-math/geometry");
var complex_visual_1 = require("../complex-visual");
var common_1 = require("./util/common");
var color_smoothing_1 = require("../../../mol-geo/geometry/mesh/color-smoothing");
var color_smoothing_2 = require("../../../mol-geo/geometry/texture-mesh/color-smoothing");
var base_1 = require("../../../mol-geo/geometry/base");
var SharedParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, gaussian_1.GaussianDensityParams), base_1.ColorSmoothingParams), { ignoreHydrogens: param_definition_1.ParamDefinition.Boolean(false), tryUseGpu: param_definition_1.ParamDefinition.Boolean(true), includeParent: param_definition_1.ParamDefinition.Boolean(false, { isHidden: true }) });
exports.GaussianSurfaceMeshParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, units_visual_1.UnitsMeshParams), units_visual_1.UnitsTextureMeshParams), SharedParams);
exports.StructureGaussianSurfaceMeshParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, complex_visual_1.ComplexMeshParams), complex_visual_1.ComplexTextureMeshParams), SharedParams);
function gpuSupport(webgl) {
    return webgl.extensions.colorBufferFloat && webgl.extensions.textureFloat && webgl.extensions.blendMinMax && webgl.extensions.drawBuffers;
}
function suitableForGpu(structure, props, webgl) {
    // lower resolutions are about as fast on CPU vs integrated GPU,
    // very low resolutions have artifacts when calculated on GPU
    if (props.resolution > 1)
        return false;
    // the GPU is much more memory contraint, especially true for integrated GPUs,
    // being conservative here still allows for small and medium sized assemblies
    var d = webgl.maxTextureSize / 3;
    var _a = (0, common_1.getVolumeSliceInfo)(structure.boundary.box, props.resolution, d * d), areaCells = _a.areaCells, maxAreaCells = _a.maxAreaCells;
    return areaCells < maxAreaCells;
}
function GaussianSurfaceVisual(materialId, structure, props, webgl) {
    if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(structure, props, webgl)) {
        return GaussianSurfaceTextureMeshVisual(materialId);
    }
    return GaussianSurfaceMeshVisual(materialId);
}
exports.GaussianSurfaceVisual = GaussianSurfaceVisual;
function StructureGaussianSurfaceVisual(materialId, structure, props, webgl) {
    if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(structure, props, webgl)) {
        return StructureGaussianSurfaceTextureMeshVisual(materialId);
    }
    return StructureGaussianSurfaceMeshVisual(materialId);
}
exports.StructureGaussianSurfaceVisual = StructureGaussianSurfaceVisual;
//
function createGaussianSurfaceMesh(ctx, unit, structure, theme, props, mesh) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var smoothness, _a, transform, field, idField, radiusFactor, resolution, params, surface, sphere;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    smoothness = props.smoothness;
                    return [4 /*yield*/, (0, gaussian_1.computeUnitGaussianDensity)(structure, unit, props).runInContext(ctx.runtime)];
                case 1:
                    _a = _b.sent(), transform = _a.transform, field = _a.field, idField = _a.idField, radiusFactor = _a.radiusFactor, resolution = _a.resolution;
                    params = {
                        isoLevel: Math.exp(-smoothness) / radiusFactor,
                        scalarField: field,
                        idField: idField
                    };
                    return [4 /*yield*/, (0, algorithm_1.computeMarchingCubesMesh)(params, mesh).runAsChild(ctx.runtime)];
                case 2:
                    surface = _b.sent();
                    surface.meta.resolution = resolution;
                    mesh_1.Mesh.transform(surface, transform);
                    if (ctx.webgl && !ctx.webgl.isWebGL2)
                        mesh_1.Mesh.uniformTriangleGroup(surface);
                    sphere = geometry_1.Sphere3D.expand((0, geometry_1.Sphere3D)(), unit.boundary.sphere, props.radiusOffset + (0, common_1.getUnitExtraRadius)(unit));
                    surface.setBoundingSphere(sphere);
                    return [2 /*return*/, surface];
            }
        });
    });
}
function GaussianSurfaceMeshVisual(materialId) {
    return (0, units_visual_1.UnitsMeshVisual)({
        defaultProps: param_definition_1.ParamDefinition.getDefaultValues(exports.GaussianSurfaceMeshParams),
        createGeometry: createGaussianSurfaceMesh,
        createLocationIterator: element_1.ElementIterator.fromGroup,
        getLoci: element_1.getElementLoci,
        eachLocation: element_1.eachElement,
        setUpdateState: function (state, newProps, currentProps) {
            if (newProps.resolution !== currentProps.resolution)
                state.createGeometry = true;
            if (newProps.radiusOffset !== currentProps.radiusOffset)
                state.createGeometry = true;
            if (newProps.smoothness !== currentProps.smoothness)
                state.createGeometry = true;
            if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
                state.createGeometry = true;
            if (newProps.traceOnly !== currentProps.traceOnly)
                state.createGeometry = true;
            if (newProps.includeParent !== currentProps.includeParent)
                state.createGeometry = true;
            if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
                state.updateColor = true;
            }
            else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {
                if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
                    state.updateColor = true;
                if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
                    state.updateColor = true;
            }
        },
        mustRecreate: function (structureGroup, props, webgl) {
            return props.tryUseGpu && !!webgl && suitableForGpu(structureGroup.structure, props, webgl);
        },
        processValues: function (values, geometry, props, theme, webgl) {
            var _a = geometry.meta, resolution = _a.resolution, colorTexture = _a.colorTexture;
            var csp = (0, base_1.getColorSmoothingProps)(props.smoothColors, theme.color.preferSmoothing, resolution);
            if (csp) {
                (0, color_smoothing_1.applyMeshColorSmoothing)(values, csp.resolution, csp.stride, webgl, colorTexture);
                geometry.meta.colorTexture = values.tColorGrid.ref.value;
            }
        },
        dispose: function (geometry) {
            var _a;
            (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }, materialId);
}
exports.GaussianSurfaceMeshVisual = GaussianSurfaceMeshVisual;
//
function createStructureGaussianSurfaceMesh(ctx, structure, theme, props, mesh) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var smoothness, _a, transform, field, idField, radiusFactor, resolution, params, surface, sphere;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    smoothness = props.smoothness;
                    return [4 /*yield*/, (0, gaussian_1.computeStructureGaussianDensity)(structure, props).runInContext(ctx.runtime)];
                case 1:
                    _a = _b.sent(), transform = _a.transform, field = _a.field, idField = _a.idField, radiusFactor = _a.radiusFactor, resolution = _a.resolution;
                    params = {
                        isoLevel: Math.exp(-smoothness) / radiusFactor,
                        scalarField: field,
                        idField: idField
                    };
                    return [4 /*yield*/, (0, algorithm_1.computeMarchingCubesMesh)(params, mesh).runAsChild(ctx.runtime)];
                case 2:
                    surface = _b.sent();
                    surface.meta.resolution = resolution;
                    mesh_1.Mesh.transform(surface, transform);
                    if (ctx.webgl && !ctx.webgl.isWebGL2)
                        mesh_1.Mesh.uniformTriangleGroup(surface);
                    sphere = geometry_1.Sphere3D.expand((0, geometry_1.Sphere3D)(), structure.boundary.sphere, props.radiusOffset + (0, common_1.getStructureExtraRadius)(structure));
                    surface.setBoundingSphere(sphere);
                    return [2 /*return*/, surface];
            }
        });
    });
}
function StructureGaussianSurfaceMeshVisual(materialId) {
    return (0, complex_visual_1.ComplexMeshVisual)({
        defaultProps: param_definition_1.ParamDefinition.getDefaultValues(exports.StructureGaussianSurfaceMeshParams),
        createGeometry: createStructureGaussianSurfaceMesh,
        createLocationIterator: element_1.ElementIterator.fromStructure,
        getLoci: element_1.getSerialElementLoci,
        eachLocation: element_1.eachSerialElement,
        setUpdateState: function (state, newProps, currentProps) {
            if (newProps.resolution !== currentProps.resolution)
                state.createGeometry = true;
            if (newProps.radiusOffset !== currentProps.radiusOffset)
                state.createGeometry = true;
            if (newProps.smoothness !== currentProps.smoothness)
                state.createGeometry = true;
            if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
                state.createGeometry = true;
            if (newProps.traceOnly !== currentProps.traceOnly)
                state.createGeometry = true;
            if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
                state.updateColor = true;
            }
            else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {
                if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
                    state.updateColor = true;
                if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
                    state.updateColor = true;
            }
        },
        mustRecreate: function (structure, props, webgl) {
            return props.tryUseGpu && !!webgl && suitableForGpu(structure, props, webgl);
        },
        processValues: function (values, geometry, props, theme, webgl) {
            var _a = geometry.meta, resolution = _a.resolution, colorTexture = _a.colorTexture;
            var csp = (0, base_1.getColorSmoothingProps)(props.smoothColors, theme.color.preferSmoothing, resolution);
            if (csp) {
                (0, color_smoothing_1.applyMeshColorSmoothing)(values, csp.resolution, csp.stride, webgl, colorTexture);
                geometry.meta.colorTexture = values.tColorGrid.ref.value;
            }
        },
        dispose: function (geometry) {
            var _a;
            (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }, materialId);
}
exports.StructureGaussianSurfaceMeshVisual = StructureGaussianSurfaceMeshVisual;
//
var GaussianSurfaceName = 'gaussian-surface';
function createGaussianSurfaceTextureMesh(ctx, unit, structure, theme, props, textureMesh) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _a, namedTextures, resources, _b, colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat, densityTextureData, isoLevel, buffer, gv, boundingSphere, surface;
        return (0, tslib_1.__generator)(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!ctx.webgl)
                        throw new Error('webgl context required to create gaussian surface texture-mesh');
                    _a = ctx.webgl, namedTextures = _a.namedTextures, resources = _a.resources, _b = _a.extensions, colorBufferFloat = _b.colorBufferFloat, textureFloat = _b.textureFloat, colorBufferHalfFloat = _b.colorBufferHalfFloat, textureHalfFloat = _b.textureHalfFloat;
                    if (!namedTextures[GaussianSurfaceName]) {
                        namedTextures[GaussianSurfaceName] = colorBufferHalfFloat && textureHalfFloat
                            ? resources.texture('image-float16', 'rgba', 'fp16', 'linear')
                            : colorBufferFloat && textureFloat
                                ? resources.texture('image-float32', 'rgba', 'float', 'linear')
                                : resources.texture('image-uint8', 'rgba', 'ubyte', 'linear');
                    }
                    return [4 /*yield*/, (0, gaussian_1.computeUnitGaussianDensityTexture2d)(structure, unit, true, props, ctx.webgl, namedTextures[GaussianSurfaceName]).runInContext(ctx.runtime)];
                case 1:
                    densityTextureData = _c.sent();
                    isoLevel = Math.exp(-props.smoothness) / densityTextureData.radiusFactor;
                    buffer = textureMesh === null || textureMesh === void 0 ? void 0 : textureMesh.doubleBuffer.get();
                    gv = (0, isosurface_1.extractIsosurface)(ctx.webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.gridTexScale, densityTextureData.transform, isoLevel, false, true, buffer === null || buffer === void 0 ? void 0 : buffer.vertex, buffer === null || buffer === void 0 ? void 0 : buffer.group, buffer === null || buffer === void 0 ? void 0 : buffer.normal);
                    boundingSphere = geometry_1.Sphere3D.expand((0, geometry_1.Sphere3D)(), unit.boundary.sphere, props.radiusOffset + (0, common_1.getStructureExtraRadius)(structure));
                    surface = texture_mesh_1.TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, boundingSphere, textureMesh);
                    surface.meta.resolution = densityTextureData.resolution;
                    return [2 /*return*/, surface];
            }
        });
    });
}
function GaussianSurfaceTextureMeshVisual(materialId) {
    return (0, units_visual_1.UnitsTextureMeshVisual)({
        defaultProps: param_definition_1.ParamDefinition.getDefaultValues(exports.GaussianSurfaceMeshParams),
        createGeometry: createGaussianSurfaceTextureMesh,
        createLocationIterator: element_1.ElementIterator.fromGroup,
        getLoci: element_1.getElementLoci,
        eachLocation: element_1.eachElement,
        setUpdateState: function (state, newProps, currentProps) {
            if (newProps.resolution !== currentProps.resolution)
                state.createGeometry = true;
            if (newProps.radiusOffset !== currentProps.radiusOffset)
                state.createGeometry = true;
            if (newProps.smoothness !== currentProps.smoothness)
                state.createGeometry = true;
            if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
                state.createGeometry = true;
            if (newProps.traceOnly !== currentProps.traceOnly)
                state.createGeometry = true;
            if (newProps.includeParent !== currentProps.includeParent)
                state.createGeometry = true;
            if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
                state.updateColor = true;
            }
            else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {
                if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
                    state.updateColor = true;
                if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
                    state.updateColor = true;
            }
        },
        mustRecreate: function (structureGroup, props, webgl) {
            return !props.tryUseGpu || !webgl || !suitableForGpu(structureGroup.structure, props, webgl);
        },
        processValues: function (values, geometry, props, theme, webgl) {
            var _a = geometry.meta, resolution = _a.resolution, colorTexture = _a.colorTexture;
            var csp = (0, base_1.getColorSmoothingProps)(props.smoothColors, theme.color.preferSmoothing, resolution);
            if (csp && webgl) {
                (0, color_smoothing_2.applyTextureMeshColorSmoothing)(values, csp.resolution, csp.stride, webgl, colorTexture);
                geometry.meta.colorTexture = values.tColorGrid.ref.value;
            }
        },
        dispose: function (geometry) {
            var _a;
            geometry.vertexTexture.ref.value.destroy();
            geometry.groupTexture.ref.value.destroy();
            geometry.normalTexture.ref.value.destroy();
            geometry.doubleBuffer.destroy();
            (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }, materialId);
}
exports.GaussianSurfaceTextureMeshVisual = GaussianSurfaceTextureMeshVisual;
//
function createStructureGaussianSurfaceTextureMesh(ctx, structure, theme, props, textureMesh) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _a, namedTextures, resources, _b, colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat, densityTextureData, isoLevel, buffer, gv, boundingSphere, surface;
        return (0, tslib_1.__generator)(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!ctx.webgl)
                        throw new Error('webgl context required to create structure gaussian surface texture-mesh');
                    _a = ctx.webgl, namedTextures = _a.namedTextures, resources = _a.resources, _b = _a.extensions, colorBufferFloat = _b.colorBufferFloat, textureFloat = _b.textureFloat, colorBufferHalfFloat = _b.colorBufferHalfFloat, textureHalfFloat = _b.textureHalfFloat;
                    if (!namedTextures[GaussianSurfaceName]) {
                        namedTextures[GaussianSurfaceName] = colorBufferHalfFloat && textureHalfFloat
                            ? resources.texture('image-float16', 'rgba', 'fp16', 'linear')
                            : colorBufferFloat && textureFloat
                                ? resources.texture('image-float32', 'rgba', 'float', 'linear')
                                : resources.texture('image-uint8', 'rgba', 'ubyte', 'linear');
                    }
                    return [4 /*yield*/, (0, gaussian_1.computeStructureGaussianDensityTexture2d)(structure, true, props, ctx.webgl, namedTextures[GaussianSurfaceName]).runInContext(ctx.runtime)];
                case 1:
                    densityTextureData = _c.sent();
                    isoLevel = Math.exp(-props.smoothness) / densityTextureData.radiusFactor;
                    buffer = textureMesh === null || textureMesh === void 0 ? void 0 : textureMesh.doubleBuffer.get();
                    gv = (0, isosurface_1.extractIsosurface)(ctx.webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.gridTexScale, densityTextureData.transform, isoLevel, false, true, buffer === null || buffer === void 0 ? void 0 : buffer.vertex, buffer === null || buffer === void 0 ? void 0 : buffer.group, buffer === null || buffer === void 0 ? void 0 : buffer.normal);
                    boundingSphere = geometry_1.Sphere3D.expand((0, geometry_1.Sphere3D)(), structure.boundary.sphere, props.radiusOffset + (0, common_1.getStructureExtraRadius)(structure));
                    surface = texture_mesh_1.TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, boundingSphere, textureMesh);
                    surface.meta.resolution = densityTextureData.resolution;
                    return [2 /*return*/, surface];
            }
        });
    });
}
function StructureGaussianSurfaceTextureMeshVisual(materialId) {
    return (0, complex_visual_1.ComplexTextureMeshVisual)({
        defaultProps: param_definition_1.ParamDefinition.getDefaultValues(exports.StructureGaussianSurfaceMeshParams),
        createGeometry: createStructureGaussianSurfaceTextureMesh,
        createLocationIterator: element_1.ElementIterator.fromStructure,
        getLoci: element_1.getSerialElementLoci,
        eachLocation: element_1.eachSerialElement,
        setUpdateState: function (state, newProps, currentProps) {
            if (newProps.resolution !== currentProps.resolution)
                state.createGeometry = true;
            if (newProps.radiusOffset !== currentProps.radiusOffset)
                state.createGeometry = true;
            if (newProps.smoothness !== currentProps.smoothness)
                state.createGeometry = true;
            if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
                state.createGeometry = true;
            if (newProps.traceOnly !== currentProps.traceOnly)
                state.createGeometry = true;
            if (newProps.includeParent !== currentProps.includeParent)
                state.createGeometry = true;
            if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
                state.updateColor = true;
            }
            else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {
                if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
                    state.updateColor = true;
                if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
                    state.updateColor = true;
            }
        },
        mustRecreate: function (structure, props, webgl) {
            return !props.tryUseGpu || !webgl || !suitableForGpu(structure, props, webgl);
        },
        processValues: function (values, geometry, props, theme, webgl) {
            var _a = geometry.meta, resolution = _a.resolution, colorTexture = _a.colorTexture;
            var csp = (0, base_1.getColorSmoothingProps)(props.smoothColors, theme.color.preferSmoothing, resolution);
            if (csp && webgl) {
                (0, color_smoothing_2.applyTextureMeshColorSmoothing)(values, csp.resolution, csp.stride, webgl, colorTexture);
                geometry.meta.colorTexture = values.tColorGrid.ref.value;
            }
        },
        dispose: function (geometry) {
            var _a;
            geometry.vertexTexture.ref.value.destroy();
            geometry.groupTexture.ref.value.destroy();
            geometry.normalTexture.ref.value.destroy();
            geometry.doubleBuffer.destroy();
            (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
        }
    }, materialId);
}
exports.StructureGaussianSurfaceTextureMeshVisual = StructureGaussianSurfaceTextureMeshVisual;
//# sourceMappingURL=gaussian-surface-mesh.js.map