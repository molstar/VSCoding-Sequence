"use strict";
/**
 * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
require("./index.html");
var util_1 = require("../../mol-canvas3d/util");
var canvas3d_1 = require("../../mol-canvas3d/canvas3d");
var names_1 = require("../../mol-util/color/names");
var geometry_1 = require("../../mol-math/geometry");
var int_1 = require("../../mol-data/int");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var gaussian_density_1 = require("../../mol-math/geometry/gaussian-density");
var active_voxels_1 = require("../../mol-gl/compute/marching-cubes/active-voxels");
var reduction_1 = require("../../mol-gl/compute/histogram-pyramid/reduction");
var isosurface_1 = require("../../mol-gl/compute/marching-cubes/isosurface");
var texture_mesh_1 = require("../../mol-geo/geometry/texture-mesh/texture-mesh");
var color_1 = require("../../mol-util/color");
var render_object_1 = require("../../mol-gl/render-object");
var representation_1 = require("../../mol-repr/representation");
var algorithm_1 = require("../../mol-geo/util/marching-cubes/algorithm");
var mesh_1 = require("../../mol-geo/geometry/mesh/mesh");
var param_definition_1 = require("../../mol-util/param-definition");
var parent = document.getElementById('app');
parent.style.width = '100%';
parent.style.height = '100%';
var canvas = document.createElement('canvas');
parent.appendChild(canvas);
(0, util_1.resizeCanvas)(canvas, parent);
var canvas3d = canvas3d_1.Canvas3D.create(canvas3d_1.Canvas3DContext.fromCanvas(canvas), param_definition_1.ParamDefinition.merge(canvas3d_1.Canvas3DParams, param_definition_1.ParamDefinition.getDefaultValues(canvas3d_1.Canvas3DParams), {
    renderer: { backgroundColor: names_1.ColorNames.white },
    camera: { mode: 'orthographic' }
}));
canvas3d.animate();
function init() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var webgl, position, box, radius, props, isoValue, densityTextureData2, activeVoxelsTex2, compacted2, densityTextureData, activeVoxelsTex, compacted, gv, mcBoundingSphere, mcIsosurface, mcIsoSurfaceProps, mcIsoSurfaceValues, mcIsoSurfaceState, mcIsoSurfaceRenderObject, mcIsoSurfaceRepr, densityData, params, surface, meshProps, meshValues, meshState, meshRenderObject, meshRepr;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    webgl = canvas3d.webgl;
                    position = {
                        x: [0, 2],
                        y: [0, 2],
                        z: [0, 2],
                        indices: int_1.OrderedSet.ofSortedArray([0, 1]),
                    };
                    box = geometry_1.Box3D.create(linear_algebra_1.Vec3.create(0, 0, 0), linear_algebra_1.Vec3.create(2, 2, 2));
                    radius = function () { return 1.8; };
                    props = {
                        resolution: 0.1,
                        radiusOffset: 0,
                        smoothness: 1.5
                    };
                    isoValue = Math.exp(-props.smoothness);
                    if (!true) return [3 /*break*/, 2];
                    console.time('gpu gaussian2');
                    return [4 /*yield*/, (0, gaussian_density_1.computeGaussianDensityTexture2d)(position, box, radius, props, webgl).run()];
                case 1:
                    densityTextureData2 = _a.sent();
                    webgl.waitForGpuCommandsCompleteSync();
                    console.timeEnd('gpu gaussian2');
                    console.time('gpu mc2');
                    console.time('gpu mc active2');
                    activeVoxelsTex2 = (0, active_voxels_1.calcActiveVoxels)(webgl, densityTextureData2.texture, densityTextureData2.gridDim, densityTextureData2.gridTexDim, isoValue, densityTextureData2.gridTexScale);
                    webgl.waitForGpuCommandsCompleteSync();
                    console.timeEnd('gpu mc active2');
                    console.time('gpu mc pyramid2');
                    compacted2 = (0, reduction_1.createHistogramPyramid)(webgl, activeVoxelsTex2, densityTextureData2.gridTexScale, densityTextureData2.gridTexDim);
                    webgl.waitForGpuCommandsCompleteSync();
                    console.timeEnd('gpu mc pyramid2');
                    console.time('gpu mc vert2');
                    (0, isosurface_1.createIsosurfaceBuffers)(webgl, activeVoxelsTex2, densityTextureData2.texture, compacted2, densityTextureData2.gridDim, densityTextureData2.gridTexDim, densityTextureData2.transform, isoValue, false, true);
                    webgl.waitForGpuCommandsCompleteSync();
                    console.timeEnd('gpu mc vert2');
                    console.timeEnd('gpu mc2');
                    _a.label = 2;
                case 2:
                    console.time('gpu gaussian');
                    return [4 /*yield*/, (0, gaussian_density_1.computeGaussianDensityTexture2d)(position, box, radius, props, webgl).run()];
                case 3:
                    densityTextureData = _a.sent();
                    webgl.waitForGpuCommandsCompleteSync();
                    console.timeEnd('gpu gaussian');
                    console.time('gpu mc');
                    console.time('gpu mc active');
                    activeVoxelsTex = (0, active_voxels_1.calcActiveVoxels)(webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, isoValue, densityTextureData.gridTexScale);
                    webgl.waitForGpuCommandsCompleteSync();
                    console.timeEnd('gpu mc active');
                    console.time('gpu mc pyramid');
                    compacted = (0, reduction_1.createHistogramPyramid)(webgl, activeVoxelsTex, densityTextureData.gridTexScale, densityTextureData.gridTexDim);
                    webgl.waitForGpuCommandsCompleteSync();
                    console.timeEnd('gpu mc pyramid');
                    console.time('gpu mc vert');
                    gv = (0, isosurface_1.createIsosurfaceBuffers)(webgl, activeVoxelsTex, densityTextureData.texture, compacted, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.transform, isoValue, false, true);
                    webgl.waitForGpuCommandsCompleteSync();
                    console.timeEnd('gpu mc vert');
                    console.timeEnd('gpu mc');
                    console.log((0, tslib_1.__assign)((0, tslib_1.__assign)({}, webgl.stats), { programCount: webgl.stats.resourceCounts.program, shaderCount: webgl.stats.resourceCounts.shader }));
                    mcBoundingSphere = geometry_1.Sphere3D.fromBox3D((0, geometry_1.Sphere3D)(), densityTextureData.bbox);
                    mcIsosurface = texture_mesh_1.TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, mcBoundingSphere);
                    mcIsoSurfaceProps = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, param_definition_1.ParamDefinition.getDefaultValues(texture_mesh_1.TextureMesh.Params)), { doubleSided: true, flatShaded: true, alpha: 1.0 });
                    mcIsoSurfaceValues = texture_mesh_1.TextureMesh.Utils.createValuesSimple(mcIsosurface, mcIsoSurfaceProps, (0, color_1.Color)(0x112299), 1);
                    mcIsoSurfaceState = texture_mesh_1.TextureMesh.Utils.createRenderableState(mcIsoSurfaceProps);
                    mcIsoSurfaceRenderObject = (0, render_object_1.createRenderObject)('texture-mesh', mcIsoSurfaceValues, mcIsoSurfaceState, -1);
                    mcIsoSurfaceRepr = representation_1.Representation.fromRenderObject('texture-mesh', mcIsoSurfaceRenderObject);
                    canvas3d.add(mcIsoSurfaceRepr);
                    canvas3d.requestCameraReset();
                    //
                    console.time('cpu gaussian');
                    return [4 /*yield*/, (0, gaussian_density_1.computeGaussianDensity)(position, box, radius, props).run()];
                case 4:
                    densityData = _a.sent();
                    console.timeEnd('cpu gaussian');
                    console.log({ densityData: densityData });
                    params = {
                        isoLevel: isoValue,
                        scalarField: densityData.field,
                        idField: densityData.idField
                    };
                    console.time('cpu mc');
                    return [4 /*yield*/, (0, algorithm_1.computeMarchingCubesMesh)(params).run()];
                case 5:
                    surface = _a.sent();
                    console.timeEnd('cpu mc');
                    console.log('surface', surface);
                    mesh_1.Mesh.transform(surface, densityData.transform);
                    meshProps = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, param_definition_1.ParamDefinition.getDefaultValues(mesh_1.Mesh.Params)), { doubleSided: true, flatShaded: false, alpha: 1.0 });
                    meshValues = mesh_1.Mesh.Utils.createValuesSimple(surface, meshProps, (0, color_1.Color)(0x995511), 1);
                    meshState = mesh_1.Mesh.Utils.createRenderableState(meshProps);
                    meshRenderObject = (0, render_object_1.createRenderObject)('mesh', meshValues, meshState, -1);
                    meshRepr = representation_1.Representation.fromRenderObject('mesh', meshRenderObject);
                    canvas3d.add(meshRepr);
                    canvas3d.requestCameraReset();
                    return [2 /*return*/];
            }
        });
    });
}
init();
//# sourceMappingURL=marching-cubes.js.map