"use strict";
/**
 * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports._struct_sheet_range = exports._struct_conf = void 0;
var tslib_1 = require("tslib");
var int_1 = require("../../../../mol-data/int");
var cif_1 = require("../../../../mol-io/writer/cif");
var structure_1 = require("../../structure");
var CifField = cif_1.CifWriter.Field;
var atom_site_1 = require("./atom_site");
var secondary_structure_1 = require("../../../../mol-model-formats/structure/property/secondary-structure");
exports._struct_conf = {
    name: 'struct_conf',
    instance: function (ctx) {
        var elements = findElements(ctx, 'helix');
        return {
            fields: struct_conf_fields(),
            source: [{ data: elements, rowCount: elements.length }]
        };
    }
};
exports._struct_sheet_range = {
    name: 'struct_sheet_range',
    instance: function (ctx) {
        var elements = findElements(ctx, 'sheet').sort(compare_ssr);
        return {
            fields: struct_sheet_range_fields(),
            source: [{ data: elements, rowCount: elements.length }]
        };
    }
};
function compare_ssr(x, y) {
    var a = x.element, b = y.element;
    return a.sheet_id < b.sheet_id ? -1 : a.sheet_id === b.sheet_id ? x.start.element - y.start.element : 1;
}
;
var struct_conf_fields = function () { return tslib_1.__spreadArray(tslib_1.__spreadArray(tslib_1.__spreadArray([
    CifField.str('conf_type_id', function (i, data) { return data[i].element.type_id; }),
    CifField.str('id', function (i, data, idx) { return "".concat(data[i].element.type_id).concat(idx + 1); })
], (0, atom_site_1.residueIdFields)(function (i, e) { return e[i].start; }, { prefix: 'beg' }), true), (0, atom_site_1.residueIdFields)(function (i, e) { return e[i].end; }, { prefix: 'end' }), true), [
    CifField.str('pdbx_PDB_helix_class', function (i, data) { return data[i].element.helix_class; }),
    CifField.str('details', function (i, data) { return data[i].element.details || ''; }, {
        valueKind: function (i, d) { return !!d[i].element.details ? 0 /* Column.ValueKind.Present */ : 2 /* Column.ValueKind.Unknown */; }
    }),
    CifField.int('pdbx_PDB_helix_length', function (i, data) { return data[i].length; })
], false); };
var struct_sheet_range_fields = function () { return tslib_1.__spreadArray(tslib_1.__spreadArray(tslib_1.__spreadArray([
    CifField.str('sheet_id', function (i, data) { return data[i].element.sheet_id; }),
    CifField.index('id')
], (0, atom_site_1.residueIdFields)(function (i, e) { return e[i].start; }, { prefix: 'beg' }), true), (0, atom_site_1.residueIdFields)(function (i, e) { return e[i].end; }, { prefix: 'end' }), true), [
    CifField.str('symmetry', function (i, data) { return ''; }, { valueKind: function (i, d) { return 2 /* Column.ValueKind.Unknown */; } })
], false); };
function findElements(ctx, kind) {
    // TODO: encode secondary structure for different models?
    var secondaryStructure = secondary_structure_1.ModelSecondaryStructure.Provider.get(ctx.firstModel);
    if (!secondaryStructure)
        return [];
    var key = secondaryStructure.key, elements = secondaryStructure.elements;
    var ssElements = [];
    var structure = ctx.structures[0];
    for (var _i = 0, _a = structure.unitSymmetryGroups; _i < _a.length; _i++) {
        var units = _a[_i].units;
        var u = units[0];
        if (!structure_1.Unit.isAtomic(u))
            continue;
        var segs = u.model.atomicHierarchy.residueAtomSegments;
        var residues = int_1.Segmentation.transientSegments(segs, u.elements);
        var current = void 0, move = true;
        while (residues.hasNext) {
            if (move)
                current = residues.move();
            var start = current.index;
            var startIdx = key[start];
            var element = elements[startIdx];
            if (element.kind !== kind) {
                move = true;
                continue;
            }
            var prev = start;
            while (residues.hasNext) {
                prev = current.index;
                current = residues.move();
                if (startIdx !== key[current.index]) {
                    move = false;
                    ssElements[ssElements.length] = {
                        start: structure_1.StructureElement.Location.create(structure, u, segs.offsets[start]),
                        end: structure_1.StructureElement.Location.create(structure, u, segs.offsets[prev]),
                        length: prev - start + 1,
                        element: element
                    };
                    break;
                }
            }
        }
    }
    return ssElements;
}
