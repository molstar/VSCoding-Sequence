"use strict";
/**
 * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.alignAndSuperposeWithBestDatabaseMapping = void 0;
var int_1 = require("../../../../mol-data/int");
var linear_algebra_1 = require("../../../../mol-math/linear-algebra");
var minimize_rmsd_1 = require("../../../../mol-math/linear-algebra/3d/minimize-rmsd");
var best_database_mapping_1 = require("../../../../mol-model-props/sequence/best-database-mapping");
function alignAndSuperposeWithBestDatabaseMapping(structures) {
    var indexMap = new Map();
    for (var i = 0; i < structures.length; i++) {
        buildIndex(structures[i], indexMap, i);
    }
    var index = Array.from(indexMap.values());
    // TODO: support non-first structure pivots
    var pairs = findPairs(structures.length, index);
    var ret = [];
    for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {
        var p = pairs_1[_i];
        var _a = getPositionTables(index, p.i, p.j, p.count), a = _a[0], b = _a[1];
        var transform = minimize_rmsd_1.MinimizeRmsd.compute({ a: a, b: b });
        console.log(linear_algebra_1.Mat4.makeTable(transform.bTransform), transform.rmsd);
        ret.push({ transform: transform, pivot: p.i, other: p.j });
    }
    return ret;
}
exports.alignAndSuperposeWithBestDatabaseMapping = alignAndSuperposeWithBestDatabaseMapping;
function getPositionTables(index, pivot, other, N) {
    var xs = minimize_rmsd_1.MinimizeRmsd.Positions.empty(N);
    var ys = minimize_rmsd_1.MinimizeRmsd.Positions.empty(N);
    var o = 0;
    for (var _i = 0, index_1 = index; _i < index_1.length; _i++) {
        var pivots = index_1[_i].pivots;
        var a = pivots[pivot];
        var b = pivots[other];
        if (!a || !b)
            continue;
        var l = Math.min(a[2] - a[1], b[2] - b[1]);
        // TODO: allow to use just backbone atoms?
        // TODO: check if residue types match?
        for (var i = 0; i < l; i++) {
            var eI = (a[1] + i);
            xs.x[o] = a[0].conformation.x(eI);
            xs.y[o] = a[0].conformation.y(eI);
            xs.z[o] = a[0].conformation.z(eI);
            eI = (b[1] + i);
            ys.x[o] = b[0].conformation.x(eI);
            ys.y[o] = b[0].conformation.y(eI);
            ys.z[o] = b[0].conformation.z(eI);
            o++;
        }
    }
    return [xs, ys];
}
function findPairs(N, index) {
    var pairwiseCounts = [];
    for (var i = 0; i < N; i++) {
        pairwiseCounts[i] = [];
        for (var j = 0; j < N; j++)
            pairwiseCounts[i][j] = 0;
    }
    for (var _i = 0, index_2 = index; _i < index_2.length; _i++) {
        var pivots = index_2[_i].pivots;
        for (var i = 0; i < N; i++) {
            if (!pivots[i])
                continue;
            var lI = pivots[i][2] - pivots[i][1];
            for (var j = i + 1; j < N; j++) {
                if (!pivots[j])
                    continue;
                var lJ = pivots[j][2] - pivots[j][1];
                pairwiseCounts[i][j] = pairwiseCounts[i][j] + Math.min(lI, lJ);
            }
        }
    }
    var ret = [];
    for (var j = 1; j < N; j++) {
        ret[j - 1] = { i: 0, j: j, count: pairwiseCounts[0][j] };
    }
    // TODO: support non-first structure pivots
    // for (let i = 0; i < N - 1; i++) {
    //     let max = 0, maxJ = i;
    //     for (let j = i + 1; j < N; j++) {
    //         if (pairwiseCounts[i][j] > max) {
    //             maxJ = j;
    //             max = pairwiseCounts[i][j];
    //         }
    //     }
    //     ret[i] = { i, j: maxJ, count: max };
    // }
    return ret;
}
function buildIndex(structure, index, sI) {
    var _a;
    for (var _i = 0, _b = structure.units; _i < _b.length; _i++) {
        var unit = _b[_i];
        if (unit.kind !== 0 /* Atomic */)
            continue;
        var elements = unit.elements, model = unit.model;
        var map = best_database_mapping_1.BestDatabaseSequenceMapping.Provider.get(model).value;
        if (!map)
            return;
        var dbName = map.dbName, accession = map.accession, num = map.num;
        var chainsIt = int_1.Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);
        var residuesIt = int_1.Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);
        while (chainsIt.hasNext) {
            var chainSegment = chainsIt.move();
            residuesIt.setSegment(chainSegment);
            while (residuesIt.hasNext) {
                var residueSegment = residuesIt.move();
                var rI = residueSegment.index;
                if (!dbName[rI])
                    continue;
                var start = elements[residueSegment.start];
                var end = elements[residueSegment.end - 1] + 1;
                var key = "".concat(dbName[rI], "-").concat(accession[rI], "-").concat(num[rI]);
                if (!index.has(key)) {
                    index.set(key, { key: key, pivots: (_a = {}, _a[sI] = [unit, start, end], _a) });
                }
                else {
                    var entry = index.get(key);
                    if (!entry.pivots[sI]) {
                        entry.pivots[sI] = [unit, start, end];
                    }
                }
            }
        }
    }
    console.log(index);
}
//# sourceMappingURL=superposition-db-mapping.js.map