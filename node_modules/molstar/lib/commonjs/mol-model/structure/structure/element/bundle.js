"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bundle = void 0;
var int_1 = require("../../../../mol-data/int");
var structure_1 = require("../structure");
var util_1 = require("../../../../mol-data/util");
var sorted_ranges_1 = require("../../../../mol-data/int/sorted-ranges");
var loci_1 = require("./loci");
var builder_1 = require("../../../../mol-script/language/builder");
var query_1 = require("../../query");
var Bundle;
(function (Bundle) {
    Bundle.Empty = { hash: -1, elements: [] };
    function fromSubStructure(parent, structure) {
        return fromLoci(query_1.StructureSelection.toLociWithSourceUnits(query_1.StructureSelection.Singletons(parent, structure)));
    }
    Bundle.fromSubStructure = fromSubStructure;
    function fromSelection(selection) {
        return fromLoci(query_1.StructureSelection.toLociWithSourceUnits(selection));
    }
    Bundle.fromSelection = fromSelection;
    function fromLoci(loci) {
        var _elements = [];
        for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {
            var e = _a[_i];
            var unit = e.unit, indices = e.indices;
            if (int_1.OrderedSet.size(indices) === 0)
                continue;
            var ranges = [];
            var set = [];
            if (int_1.OrderedSet.isInterval(indices)) {
                if (int_1.OrderedSet.size(indices) === 1) {
                    set.push(int_1.Interval.min(indices));
                }
                else {
                    ranges.push(int_1.Interval.min(indices), int_1.Interval.max(indices));
                }
            }
            else {
                var i = 0;
                var len = indices.length;
                while (i < len) {
                    var start = i;
                    i++;
                    while (i < len && indices[i - 1] + 1 === indices[i])
                        i++;
                    var end = i;
                    if (end - start > 2) {
                        ranges.push(indices[start], indices[end - 1]);
                    }
                    else {
                        for (var j = start; j < end; j++) {
                            set[set.length] = indices[j];
                        }
                    }
                }
            }
            _elements.push({
                unit: unit,
                set: int_1.SortedArray.ofSortedArray(set),
                ranges: sorted_ranges_1.SortedRanges.ofSortedRanges(ranges)
            });
        }
        var elementGroups = new Map();
        for (var i = 0, il = _elements.length; i < il; ++i) {
            var e = _elements[i];
            var key = (0, util_1.hash2)((0, util_1.hashFnv32a)(e.ranges), (0, util_1.hashFnv32a)(e.set));
            if (elementGroups.has(key)) {
                var groupedUnits = elementGroups.get(key).groupedUnits;
                if (groupedUnits.has(e.unit.invariantId)) {
                    groupedUnits.get(e.unit.invariantId).push(e.unit.id);
                }
                else {
                    groupedUnits.set(e.unit.invariantId, [e.unit.id]);
                }
            }
            else {
                var groupedUnits = new Map();
                groupedUnits.set(e.unit.invariantId, [e.unit.id]);
                elementGroups.set(key, { groupedUnits: groupedUnits, set: e.set, ranges: e.ranges });
            }
        }
        var elements = [];
        elementGroups.forEach(function (e) {
            var groupedUnits = [];
            e.groupedUnits.forEach(function (g) { return groupedUnits.push(int_1.SortedArray.ofUnsortedArray(g)); });
            groupedUnits.sort(function (a, b) { return a[0] - b[0]; }); // sort by first unit id of each group
            elements.push({ groupedUnits: groupedUnits, set: e.set, ranges: e.ranges });
        });
        return { hash: loci.structure.hashCode, elements: elements };
    }
    Bundle.fromLoci = fromLoci;
    function getUnitsFromIds(unitIds, structure) {
        var units = [];
        for (var i = 0, il = unitIds.length; i < il; ++i) {
            var unitId = unitIds[i];
            if (structure.unitMap.has(unitId))
                units.push(structure.unitMap.get(unitId));
        }
        return units;
    }
    function toLoci(bundle, structure) {
        if (bundle.hash !== -1 && bundle.hash !== structure.hashCode) {
            new Error('Bundle not compatible with given structure');
        }
        var elements = [];
        for (var _i = 0, _a = bundle.elements; _i < _a.length; _i++) {
            var e = _a[_i];
            var _loop_1 = function (g) {
                var units = getUnitsFromIds(g, structure);
                if (units.length === 0)
                    return "continue";
                var indices = void 0;
                if (e.ranges.length === 0) {
                    indices = e.set;
                }
                else if (e.set.length === 0) {
                    if (e.ranges.length === 2) {
                        indices = int_1.Interval.ofRange(e.ranges[0], e.ranges[1]);
                    }
                    else {
                        var _indices_1 = new Int32Array(sorted_ranges_1.SortedRanges.size(e.ranges));
                        sorted_ranges_1.SortedRanges.forEach(e.ranges, function (v, i) { return _indices_1[i] = v; });
                        indices = int_1.SortedArray.ofSortedArray(_indices_1);
                    }
                }
                else {
                    var rangesSize = sorted_ranges_1.SortedRanges.size(e.ranges);
                    var _indices_2 = new Int32Array(e.set.length + rangesSize);
                    sorted_ranges_1.SortedRanges.forEach(e.ranges, function (v, i) { return _indices_2[i] = v; });
                    _indices_2.set(e.set, rangesSize);
                    indices = int_1.SortedArray.ofUnsortedArray(_indices_2); // requires sort
                }
                for (var _d = 0, units_1 = units; _d < units_1.length; _d++) {
                    var unit = units_1[_d];
                    elements.push({ unit: unit, indices: indices });
                }
            };
            for (var _b = 0, _c = e.groupedUnits; _b < _c.length; _b++) {
                var g = _c[_b];
                _loop_1(g);
            }
        }
        return (0, loci_1.Loci)(structure, elements);
    }
    Bundle.toLoci = toLoci;
    function toStructure(bundle, parent) {
        if (bundle.hash !== -1 && bundle.hash !== parent.hashCode) {
            new Error('Bundle not compatible with given structure');
        }
        var units = [];
        for (var _i = 0, _a = bundle.elements; _i < _a.length; _i++) {
            var e = _a[_i];
            var _loop_2 = function (g) {
                var _units = getUnitsFromIds(g, parent);
                if (_units.length === 0)
                    return "continue";
                var ue = _units[0].elements; // the elements are grouped by unit.invariantId
                var rangesSize = sorted_ranges_1.SortedRanges.size(e.ranges);
                var setSize = e.set.length;
                var _indices = new Int32Array(setSize + rangesSize);
                var indices = void 0;
                if (rangesSize === 0) {
                    for (var i = 0, il = setSize; i < il; ++i) {
                        _indices[i] = ue[e.set[i]];
                    }
                    indices = int_1.SortedArray.ofSortedArray(_indices);
                }
                else if (setSize === 0) {
                    sorted_ranges_1.SortedRanges.forEach(e.ranges, function (v, i) { return _indices[i] = ue[v]; });
                    indices = int_1.SortedArray.ofSortedArray(_indices);
                }
                else {
                    if (int_1.SortedArray.min(e.set) > sorted_ranges_1.SortedRanges.max(e.ranges)) {
                        sorted_ranges_1.SortedRanges.forEach(e.ranges, function (v, i) { return _indices[i] = ue[v]; });
                        for (var i = 0, il = setSize; i < il; ++i) {
                            _indices[i + rangesSize] = ue[e.set[i]];
                        }
                        indices = int_1.SortedArray.ofSortedArray(_indices);
                    }
                    else if (sorted_ranges_1.SortedRanges.min(e.ranges) > int_1.SortedArray.max(e.set)) {
                        for (var i = 0, il = setSize; i < il; ++i) {
                            _indices[i] = ue[e.set[i]];
                        }
                        sorted_ranges_1.SortedRanges.forEach(e.ranges, function (v, i) { return _indices[i + setSize] = ue[v]; });
                        indices = int_1.SortedArray.ofSortedArray(_indices);
                    }
                    else {
                        sorted_ranges_1.SortedRanges.forEach(e.ranges, function (v, i) { return _indices[i] = ue[v]; });
                        for (var i = 0, il = setSize; i < il; ++i) {
                            _indices[i + rangesSize] = ue[e.set[i]];
                        }
                        indices = int_1.SortedArray.ofUnsortedArray(_indices); // requires sort
                    }
                }
                for (var _d = 0, _units_1 = _units; _d < _units_1.length; _d++) {
                    var unit = _units_1[_d];
                    units.push(unit.getChild(indices));
                }
            };
            for (var _b = 0, _c = e.groupedUnits; _b < _c.length; _b++) {
                var g = _c[_b];
                _loop_2(g);
            }
        }
        return structure_1.Structure.create(units, { parent: parent });
    }
    Bundle.toStructure = toStructure;
    function elementToExpression(e) {
        return builder_1.MolScriptBuilder.internal.generator.bundleElement({
            groupedUnits: builder_1.MolScriptBuilder.core.type.list(e.groupedUnits.map(function (u) { return builder_1.MolScriptBuilder.core.type.list(u); })),
            ranges: builder_1.MolScriptBuilder.core.type.list(e.ranges),
            set: builder_1.MolScriptBuilder.core.type.list(e.set),
        });
    }
    function toExpression(bundle) {
        return builder_1.MolScriptBuilder.internal.generator.bundle({
            elements: builder_1.MolScriptBuilder.core.type.list(bundle.elements.map(elementToExpression))
        });
    }
    Bundle.toExpression = toExpression;
    function areEqual(a, b) {
        if (a.elements.length !== b.elements.length)
            return false;
        for (var i = 0, il = a.elements.length; i < il; ++i) {
            var elementA = a.elements[i], elementB = b.elements[i];
            if (elementA.groupedUnits.length !== elementB.groupedUnits.length)
                return false;
            for (var j = 0, jl = elementB.groupedUnits.length; j < jl; ++j) {
                if (!int_1.SortedArray.areEqual(elementA.groupedUnits[j], elementB.groupedUnits[j]))
                    return false;
            }
            if (!int_1.SortedArray.areEqual(elementA.set, elementB.set))
                return false;
            if (!sorted_ranges_1.SortedRanges.areEqual(elementA.ranges, elementB.ranges))
                return false;
        }
        return true;
    }
    Bundle.areEqual = areEqual;
})(Bundle = exports.Bundle || (exports.Bundle = {}));
