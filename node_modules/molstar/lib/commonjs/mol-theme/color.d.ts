/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { Color } from '../mol-util/color';
import { Location } from '../mol-model/location';
import { ColorType } from '../mol-geo/geometry/color-data';
import { ParamDefinition as PD } from '../mol-util/param-definition';
import { ThemeDataContext, ThemeRegistry, ThemeProvider } from './theme';
import { ScaleLegend, TableLegend } from '../mol-util/legend';
import { TextureFilter } from '../mol-gl/webgl/texture';
export declare type LocationColor = (location: Location, isSecondary: boolean) => Color;
export { ColorTheme };
interface ColorTheme<P extends PD.Params> {
    readonly factory: ColorTheme.Factory<P>;
    readonly granularity: ColorType;
    readonly color: LocationColor;
    readonly props: Readonly<PD.Values<P>>;
    /**
     * if palette is defined, 24bit RGB color value normalized to interval [0, 1]
     * is used as index to the colors
     */
    readonly palette?: Readonly<ColorTheme.Palette>;
    readonly preferSmoothing?: boolean;
    readonly contextHash?: number;
    readonly description?: string;
    readonly legend?: Readonly<ScaleLegend | TableLegend>;
}
declare namespace ColorTheme {
    export const enum Category {
        Atom = "Atom Property",
        Chain = "Chain Property",
        Residue = "Residue Property",
        Symmetry = "Symmetry",
        Validation = "Validation",
        Misc = "Miscellaneous"
    }
    export interface Palette {
        filter?: TextureFilter;
        colors: Color[];
    }
    export const PaletteScale: number;
    export type Props = {
        [k: string]: any;
    };
    export type Factory<P extends PD.Params> = (ctx: ThemeDataContext, props: PD.Values<P>) => ColorTheme<P>;
    export const EmptyFactory: () => ColorTheme<{}>;
    export const Empty: ColorTheme<{}>;
    export function areEqual(themeA: ColorTheme<any>, themeB: ColorTheme<any>): boolean;
    export interface Provider<P extends PD.Params = any, Id extends string = string> extends ThemeProvider<ColorTheme<P>, P, Id> {
    }
    export const EmptyProvider: Provider<{}>;
    export type Registry = ThemeRegistry<ColorTheme<any>>;
    export function createRegistry(): ThemeRegistry<ColorTheme<{}>>;
    export const BuiltIn: {
        'atom-id': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "atom-id">;
        'carbohydrate-symbol': Provider<{}, "carbohydrate-symbol">;
        'chain-id': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
            asymId: PD.Select<"label" | "auth">;
        }, "chain-id">;
        'element-index': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "element-index">;
        'element-symbol': Provider<{
            carbonColor: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "element-symbol"> | PD.NamedParams<PD.Normalize<{
                palette: PD.NamedParams<PD.Normalize<{
                    maxCount: any;
                    hue: any;
                    chroma: any;
                    luminance: any;
                    clusteringStepCount: any;
                    minSampleCount: any;
                }>, "generate"> | PD.NamedParams<PD.Normalize<{
                    list: any;
                }>, "colors">;
                asymId: "label" | "auth";
            }>, "chain-id"> | PD.NamedParams<PD.Normalize<{
                palette: PD.NamedParams<PD.Normalize<{
                    maxCount: any;
                    hue: any;
                    chroma: any;
                    luminance: any;
                    clusteringStepCount: any;
                    minSampleCount: any;
                }>, "generate"> | PD.NamedParams<PD.Normalize<{
                    list: any;
                }>, "colors">;
            }>, "operator-name">>;
            saturation: PD.Numeric;
            lightness: PD.Numeric;
        }, "element-symbol">;
        'entity-id': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "entity-id">;
        'entity-source': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "entity-source">;
        hydrophobicity: Provider<{
            list: PD.ColorList;
            scale: PD.Select<"DGwif" | "DGwoct" | "Oct-IF">;
        }, "hydrophobicity">;
        illustrative: Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
            asymId: PD.Select<"label" | "auth">;
        }, "illustrative">;
        'model-index': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "model-index">;
        'molecule-type': Provider<{
            saturation: PD.Numeric;
            lightness: PD.Numeric;
        }, "molecule-type">;
        occupancy: Provider<{
            domain: PD.Interval;
            list: PD.ColorList;
        }, "occupancy">;
        'operator-hkl': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "operator-hkl">;
        'operator-name': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "operator-name">;
        'partial-charge': Provider<{
            domain: PD.Interval;
            list: PD.ColorList;
        }, "partial-charge">;
        'polymer-id': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "polymer-id">;
        'polymer-index': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "polymer-index">;
        'residue-name': Provider<{
            saturation: PD.Numeric;
            lightness: PD.Numeric;
        }, "residue-name">;
        'secondary-structure': Provider<{
            saturation: PD.Numeric;
            lightness: PD.Numeric;
        }, "secondary-structure">;
        'sequence-id': Provider<{
            list: PD.ColorList;
        }, "sequence-id">;
        'shape-group': Provider<{}, "shape-group">;
        uncertainty: Provider<{
            domain: PD.Interval;
            list: PD.ColorList;
        }, "uncertainty">;
        'unit-index': Provider<{
            palette: PD.Mapped<PD.NamedParams<PD.Normalize<{
                maxCount: number;
                hue: [number, number];
                chroma: [number, number];
                luminance: [number, number];
                clusteringStepCount: number;
                minSampleCount: number;
            }>, "generate"> | PD.NamedParams<PD.Normalize<{
                list: {
                    kind: "set" | "interpolate";
                    colors: import("../mol-util/color/color").ColorListEntry[];
                };
            }>, "colors">>;
        }, "unit-index">;
        uniform: Provider<{
            value: PD.Color;
        }, "uniform">;
    };
    type _BuiltIn = typeof BuiltIn;
    export type BuiltIn = keyof _BuiltIn;
    export type ParamValues<C extends ColorTheme.Provider<any>> = C extends ColorTheme.Provider<infer P> ? PD.Values<P> : never;
    export type BuiltInParams<T extends BuiltIn> = Partial<ParamValues<_BuiltIn[T]>>;
    export {};
}
export declare function ColorThemeProvider<P extends PD.Params, Id extends string>(p: ColorTheme.Provider<P, Id>): ColorTheme.Provider<P, Id>;
