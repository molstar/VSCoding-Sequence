"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Overpaint = void 0;
var loci_1 = require("../mol-model/loci");
var color_1 = require("../mol-util/color");
var structure_1 = require("../mol-model/structure");
var script_1 = require("../mol-script/script");
function Overpaint(layers) {
    return { layers: layers };
}
exports.Overpaint = Overpaint;
(function (Overpaint) {
    Overpaint.Empty = { layers: [] };
    function areEqual(oA, oB) {
        if (oA.layers.length === 0 && oB.layers.length === 0)
            return true;
        if (oA.layers.length !== oB.layers.length)
            return false;
        for (var i = 0, il = oA.layers.length; i < il; ++i) {
            if (oA.layers[i].clear !== oB.layers[i].clear)
                return false;
            if (oA.layers[i].color !== oB.layers[i].color)
                return false;
            if (!loci_1.Loci.areEqual(oA.layers[i].loci, oB.layers[i].loci))
                return false;
        }
        return true;
    }
    Overpaint.areEqual = areEqual;
    function isEmpty(overpaint) {
        return overpaint.layers.length === 0;
    }
    Overpaint.isEmpty = isEmpty;
    function remap(overpaint, structure) {
        var layers = [];
        for (var _i = 0, _a = overpaint.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            var loci = layer.loci, color = layer.color, clear = layer.clear;
            loci = structure_1.StructureElement.Loci.remap(loci, structure);
            if (!structure_1.StructureElement.Loci.isEmpty(loci)) {
                layers.push({ loci: loci, color: color, clear: clear });
            }
        }
        return { layers: layers };
    }
    Overpaint.remap = remap;
    function merge(overpaint) {
        if (isEmpty(overpaint))
            return overpaint;
        var structure = overpaint.layers[0].loci.structure;
        var map = new Map();
        var shadowed = structure_1.StructureElement.Loci.none(structure);
        for (var i = 0, il = overpaint.layers.length; i < il; ++i) {
            var _a = overpaint.layers[il - i - 1], loci = _a.loci, color = _a.color, clear = _a.clear; // process from end
            loci = structure_1.StructureElement.Loci.subtract(loci, shadowed);
            shadowed = structure_1.StructureElement.Loci.union(loci, shadowed);
            if (!structure_1.StructureElement.Loci.isEmpty(loci)) {
                var colorOrClear = clear ? -1 : color;
                if (map.has(colorOrClear)) {
                    loci = structure_1.StructureElement.Loci.union(loci, map.get(colorOrClear));
                }
                map.set(colorOrClear, loci);
            }
        }
        var layers = [];
        map.forEach(function (loci, colorOrClear) {
            var clear = colorOrClear === -1;
            var color = clear ? (0, color_1.Color)(0) : colorOrClear;
            layers.push({ loci: loci, color: color, clear: clear });
        });
        return { layers: layers };
    }
    Overpaint.merge = merge;
    function filter(overpaint, filter) {
        if (isEmpty(overpaint))
            return overpaint;
        var structure = overpaint.layers[0].loci.structure;
        var layers = [];
        for (var _i = 0, _a = overpaint.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            var loci = layer.loci, color = layer.color, clear = layer.clear;
            // filter by first map to the `filter` structure and
            // then map back to the original structure of the overpaint loci
            var filtered = structure_1.StructureElement.Loci.remap(loci, filter);
            loci = structure_1.StructureElement.Loci.remap(filtered, structure);
            if (!structure_1.StructureElement.Loci.isEmpty(loci)) {
                layers.push({ loci: loci, color: color, clear: clear });
            }
        }
        return { layers: layers };
    }
    Overpaint.filter = filter;
    function ofScript(scriptLayers, structure) {
        var layers = [];
        for (var i = 0, il = scriptLayers.length; i < il; ++i) {
            var _a = scriptLayers[i], script = _a.script, color = _a.color, clear = _a.clear;
            var loci = script_1.Script.toLoci(script, structure);
            if (!structure_1.StructureElement.Loci.isEmpty(loci)) {
                layers.push({ loci: loci, color: color, clear: clear });
            }
        }
        return { layers: layers };
    }
    Overpaint.ofScript = ofScript;
    function ofBundle(bundleLayers, structure) {
        var layers = [];
        for (var i = 0, il = bundleLayers.length; i < il; ++i) {
            var _a = bundleLayers[i], bundle = _a.bundle, color = _a.color, clear = _a.clear;
            var loci = structure_1.StructureElement.Bundle.toLoci(bundle, structure.root);
            layers.push({ loci: loci, color: color, clear: clear });
        }
        return { layers: layers };
    }
    Overpaint.ofBundle = ofBundle;
    function toBundle(overpaint) {
        var layers = [];
        for (var i = 0, il = overpaint.layers.length; i < il; ++i) {
            var _a = overpaint.layers[i], loci = _a.loci, color = _a.color, clear = _a.clear;
            var bundle = structure_1.StructureElement.Bundle.fromLoci(loci);
            layers.push({ bundle: bundle, color: color, clear: clear });
        }
        return { layers: layers };
    }
    Overpaint.toBundle = toBundle;
})(Overpaint || (Overpaint = {}));
exports.Overpaint = Overpaint;
