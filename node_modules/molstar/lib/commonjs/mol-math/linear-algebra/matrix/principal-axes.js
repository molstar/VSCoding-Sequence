"use strict";
/**
 * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrincipalAxes = void 0;
var matrix_1 = require("./matrix");
var vec3_1 = require("../3d/vec3");
var svd_1 = require("./svd");
var geometry_1 = require("../../geometry");
var PrincipalAxes;
(function (PrincipalAxes) {
    function ofPositions(positions) {
        var momentsAxes = calculateMomentsAxes(positions);
        var boxAxes = calculateBoxAxes(positions, momentsAxes);
        return { momentsAxes: momentsAxes, boxAxes: boxAxes };
    }
    PrincipalAxes.ofPositions = ofPositions;
    function calculateMomentsAxes(positions) {
        if (positions.length === 3) {
            return geometry_1.Axes3D.create(vec3_1.Vec3.fromArray((0, vec3_1.Vec3)(), positions, 0), vec3_1.Vec3.create(1, 0, 0), vec3_1.Vec3.create(0, 1, 0), vec3_1.Vec3.create(0, 1, 0));
        }
        var points = matrix_1.Matrix.fromArray(positions, 3, positions.length / 3);
        var n = points.rows;
        var n3 = n / 3;
        var A = matrix_1.Matrix.create(3, 3);
        var W = matrix_1.Matrix.create(1, 3);
        var U = matrix_1.Matrix.create(3, 3);
        var V = matrix_1.Matrix.create(3, 3);
        // calculate
        var mean = matrix_1.Matrix.meanRows(points);
        var pointsM = matrix_1.Matrix.subRows(matrix_1.Matrix.clone(points), mean);
        var pointsT = matrix_1.Matrix.transpose(matrix_1.Matrix.create(n, 3), pointsM);
        matrix_1.Matrix.multiplyABt(A, pointsT, pointsT);
        (0, svd_1.svd)(A, W, U, V);
        // origin
        var origin = vec3_1.Vec3.create(mean[0], mean[1], mean[2]);
        // directions
        var dirA = vec3_1.Vec3.create(U.data[0], U.data[3], U.data[6]);
        var dirB = vec3_1.Vec3.create(U.data[1], U.data[4], U.data[7]);
        var dirC = vec3_1.Vec3.create(U.data[2], U.data[5], U.data[8]);
        vec3_1.Vec3.scale(dirA, dirA, Math.sqrt(W.data[0] / n3));
        vec3_1.Vec3.scale(dirB, dirB, Math.sqrt(W.data[1] / n3));
        vec3_1.Vec3.scale(dirC, dirC, Math.sqrt(W.data[2] / n3));
        return geometry_1.Axes3D.create(origin, dirA, dirB, dirC);
    }
    PrincipalAxes.calculateMomentsAxes = calculateMomentsAxes;
    var tmpBoxVec = (0, vec3_1.Vec3)();
    var tmpBoxVecA = (0, vec3_1.Vec3)();
    var tmpBoxVecB = (0, vec3_1.Vec3)();
    var tmpBoxVecC = (0, vec3_1.Vec3)();
    /**
     * Get the scale/length for each dimension for a box around the axes
     * to enclose the given positions
     */
    function calculateBoxAxes(positions, momentsAxes) {
        if (positions.length === 3) {
            return geometry_1.Axes3D.clone(momentsAxes);
        }
        var d1a = -Infinity;
        var d1b = -Infinity;
        var d2a = -Infinity;
        var d2b = -Infinity;
        var d3a = -Infinity;
        var d3b = -Infinity;
        var p = (0, vec3_1.Vec3)();
        var t = (0, vec3_1.Vec3)();
        var center = momentsAxes.origin;
        var normVecA = vec3_1.Vec3.normalize(tmpBoxVecA, momentsAxes.dirA);
        var normVecB = vec3_1.Vec3.normalize(tmpBoxVecB, momentsAxes.dirB);
        var normVecC = vec3_1.Vec3.normalize(tmpBoxVecC, momentsAxes.dirC);
        for (var i = 0, il = positions.length; i < il; i += 3) {
            vec3_1.Vec3.projectPointOnVector(p, vec3_1.Vec3.fromArray(p, positions, i), normVecA, center);
            var dp1 = vec3_1.Vec3.dot(normVecA, vec3_1.Vec3.normalize(t, vec3_1.Vec3.sub(t, p, center)));
            var dt1 = vec3_1.Vec3.distance(p, center);
            if (dp1 > 0) {
                if (dt1 > d1a)
                    d1a = dt1;
            }
            else {
                if (dt1 > d1b)
                    d1b = dt1;
            }
            vec3_1.Vec3.projectPointOnVector(p, vec3_1.Vec3.fromArray(p, positions, i), normVecB, center);
            var dp2 = vec3_1.Vec3.dot(normVecB, vec3_1.Vec3.normalize(t, vec3_1.Vec3.sub(t, p, center)));
            var dt2 = vec3_1.Vec3.distance(p, center);
            if (dp2 > 0) {
                if (dt2 > d2a)
                    d2a = dt2;
            }
            else {
                if (dt2 > d2b)
                    d2b = dt2;
            }
            vec3_1.Vec3.projectPointOnVector(p, vec3_1.Vec3.fromArray(p, positions, i), normVecC, center);
            var dp3 = vec3_1.Vec3.dot(normVecC, vec3_1.Vec3.normalize(t, vec3_1.Vec3.sub(t, p, center)));
            var dt3 = vec3_1.Vec3.distance(p, center);
            if (dp3 > 0) {
                if (dt3 > d3a)
                    d3a = dt3;
            }
            else {
                if (dt3 > d3b)
                    d3b = dt3;
            }
        }
        var dirA = vec3_1.Vec3.setMagnitude((0, vec3_1.Vec3)(), normVecA, (d1a + d1b) / 2);
        var dirB = vec3_1.Vec3.setMagnitude((0, vec3_1.Vec3)(), normVecB, (d2a + d2b) / 2);
        var dirC = vec3_1.Vec3.setMagnitude((0, vec3_1.Vec3)(), normVecC, (d3a + d3b) / 2);
        var origin = (0, vec3_1.Vec3)();
        var addCornerHelper = function (d1, d2, d3) {
            vec3_1.Vec3.copy(tmpBoxVec, center);
            vec3_1.Vec3.scaleAndAdd(tmpBoxVec, tmpBoxVec, normVecA, d1);
            vec3_1.Vec3.scaleAndAdd(tmpBoxVec, tmpBoxVec, normVecB, d2);
            vec3_1.Vec3.scaleAndAdd(tmpBoxVec, tmpBoxVec, normVecC, d3);
            vec3_1.Vec3.add(origin, origin, tmpBoxVec);
        };
        addCornerHelper(d1a, d2a, d3a);
        addCornerHelper(d1a, d2a, -d3b);
        addCornerHelper(d1a, -d2b, -d3b);
        addCornerHelper(d1a, -d2b, d3a);
        addCornerHelper(-d1b, -d2b, -d3b);
        addCornerHelper(-d1b, -d2b, d3a);
        addCornerHelper(-d1b, d2a, d3a);
        addCornerHelper(-d1b, d2a, -d3b);
        vec3_1.Vec3.scale(origin, origin, 1 / 8);
        return geometry_1.Axes3D.create(origin, dirA, dirB, dirC);
    }
    PrincipalAxes.calculateBoxAxes = calculateBoxAxes;
})(PrincipalAxes || (PrincipalAxes = {}));
exports.PrincipalAxes = PrincipalAxes;
//# sourceMappingURL=principal-axes.js.map