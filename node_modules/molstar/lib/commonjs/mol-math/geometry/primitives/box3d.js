"use strict";
/**
 * Copyright (c) 2018-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Box3D = void 0;
var linear_algebra_1 = require("../../linear-algebra");
var int_1 = require("../../../mol-data/int");
var sphere3d_1 = require("./sphere3d");
function Box3D() {
    return Box3D.zero();
}
exports.Box3D = Box3D;
(function (Box3D) {
    function create(min, max) { return { min: min, max: max }; }
    Box3D.create = create;
    function zero() { return { min: (0, linear_algebra_1.Vec3)(), max: (0, linear_algebra_1.Vec3)() }; }
    Box3D.zero = zero;
    function copy(out, a) {
        linear_algebra_1.Vec3.copy(out.min, a.min);
        linear_algebra_1.Vec3.copy(out.max, a.max);
        return out;
    }
    Box3D.copy = copy;
    function clone(a) {
        return copy(zero(), a);
    }
    Box3D.clone = clone;
    /** Get box from sphere, uses extrema if available */
    function fromSphere3D(out, sphere) {
        if (sphere3d_1.Sphere3D.hasExtrema(sphere) && sphere.extrema.length >= 14) { // 14 extrema with coarse boundary helper
            return fromVec3Array(out, sphere.extrema);
        }
        var r = linear_algebra_1.Vec3.create(sphere.radius, sphere.radius, sphere.radius);
        linear_algebra_1.Vec3.sub(out.min, sphere.center, r);
        linear_algebra_1.Vec3.add(out.max, sphere.center, r);
        return out;
    }
    Box3D.fromSphere3D = fromSphere3D;
    /** Get box from sphere, uses extrema if available */
    function fromVec3Array(out, array) {
        Box3D.setEmpty(out);
        for (var i = 0, il = array.length; i < il; i++) {
            Box3D.add(out, array[i]);
        }
        return out;
    }
    Box3D.fromVec3Array = fromVec3Array;
    function computeBounding(data) {
        var min = linear_algebra_1.Vec3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        var max = linear_algebra_1.Vec3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        var x = data.x, y = data.y, z = data.z, indices = data.indices;
        for (var t = 0, _t = int_1.OrderedSet.size(indices); t < _t; t++) {
            var i = int_1.OrderedSet.getAt(indices, t);
            min[0] = Math.min(x[i], min[0]);
            min[1] = Math.min(y[i], min[1]);
            min[2] = Math.min(z[i], min[2]);
            max[0] = Math.max(x[i], max[0]);
            max[1] = Math.max(y[i], max[1]);
            max[2] = Math.max(z[i], max[2]);
        }
        return { min: min, max: max };
    }
    Box3D.computeBounding = computeBounding;
    /** Get size/extent of the box */
    function size(size, box) {
        return linear_algebra_1.Vec3.sub(size, box.max, box.min);
    }
    Box3D.size = size;
    var tmpSizeV = (0, linear_algebra_1.Vec3)();
    /** Get volume of the box */
    function volume(box) {
        size(tmpSizeV, box);
        return tmpSizeV[0] * tmpSizeV[1] * tmpSizeV[2];
    }
    Box3D.volume = volume;
    /** Sets min to Number.MAX_VALUE and max to -Number.MAX_VALUE */
    function setEmpty(box) {
        linear_algebra_1.Vec3.set(box.min, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        linear_algebra_1.Vec3.set(box.max, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        return box;
    }
    Box3D.setEmpty = setEmpty;
    /** Add point to box */
    function add(box, point) {
        linear_algebra_1.Vec3.min(box.min, box.min, point);
        linear_algebra_1.Vec3.max(box.max, box.max, point);
        return box;
    }
    Box3D.add = add;
    /** Expand box by delta */
    function expand(out, box, delta) {
        linear_algebra_1.Vec3.sub(out.min, box.min, delta);
        linear_algebra_1.Vec3.add(out.max, box.max, delta);
        return out;
    }
    Box3D.expand = expand;
    function scale(out, box, scale) {
        linear_algebra_1.Vec3.scale(out.min, box.min, scale);
        linear_algebra_1.Vec3.scale(out.max, box.max, scale);
        return out;
    }
    Box3D.scale = scale;
    var tmpTransformV = (0, linear_algebra_1.Vec3)();
    /** Transform box with a Mat4 */
    function transform(out, box, m) {
        var _a = box.min, minX = _a[0], minY = _a[1], minZ = _a[2];
        var _b = box.max, maxX = _b[0], maxY = _b[1], maxZ = _b[2];
        setEmpty(out);
        add(out, linear_algebra_1.Vec3.transformMat4(tmpTransformV, linear_algebra_1.Vec3.set(tmpTransformV, minX, minY, minZ), m));
        add(out, linear_algebra_1.Vec3.transformMat4(tmpTransformV, linear_algebra_1.Vec3.set(tmpTransformV, minX, minY, maxZ), m));
        add(out, linear_algebra_1.Vec3.transformMat4(tmpTransformV, linear_algebra_1.Vec3.set(tmpTransformV, minX, maxY, minZ), m));
        add(out, linear_algebra_1.Vec3.transformMat4(tmpTransformV, linear_algebra_1.Vec3.set(tmpTransformV, minX, maxY, maxZ), m));
        add(out, linear_algebra_1.Vec3.transformMat4(tmpTransformV, linear_algebra_1.Vec3.set(tmpTransformV, maxX, minY, minZ), m));
        add(out, linear_algebra_1.Vec3.transformMat4(tmpTransformV, linear_algebra_1.Vec3.set(tmpTransformV, maxX, minY, maxZ), m));
        add(out, linear_algebra_1.Vec3.transformMat4(tmpTransformV, linear_algebra_1.Vec3.set(tmpTransformV, maxX, maxY, minZ), m));
        add(out, linear_algebra_1.Vec3.transformMat4(tmpTransformV, linear_algebra_1.Vec3.set(tmpTransformV, maxX, maxY, maxZ), m));
        return out;
    }
    Box3D.transform = transform;
    function containsVec3(box, v) {
        return !(v[0] < box.min[0] || v[0] > box.max[0] ||
            v[1] < box.min[1] || v[1] > box.max[1] ||
            v[2] < box.min[2] || v[2] > box.max[2]);
    }
    Box3D.containsVec3 = containsVec3;
    function overlaps(a, b) {
        return !(a.max[0] < b.min[0] || a.min[0] > b.max[0] ||
            a.max[1] < b.min[1] || a.min[1] > b.max[1] ||
            a.max[2] < b.min[2] || a.min[2] > b.max[2]);
    }
    Box3D.overlaps = overlaps;
    // const tmpTransformV = Vec3();
    function nearestIntersectionWithRay(out, box, origin, dir) {
        var _a = box.min, minX = _a[0], minY = _a[1], minZ = _a[2];
        var _b = box.max, maxX = _b[0], maxY = _b[1], maxZ = _b[2];
        var x = origin[0], y = origin[1], z = origin[2];
        var invDirX = 1.0 / dir[0];
        var invDirY = 1.0 / dir[1];
        var invDirZ = 1.0 / dir[2];
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        if (invDirX >= 0) {
            tmin = (minX - x) * invDirX;
            tmax = (maxX - x) * invDirX;
        }
        else {
            tmin = (maxX - x) * invDirX;
            tmax = (minX - x) * invDirX;
        }
        if (invDirY >= 0) {
            tymin = (minY - y) * invDirY;
            tymax = (maxY - y) * invDirY;
        }
        else {
            tymin = (maxY - y) * invDirY;
            tymax = (minY - y) * invDirY;
        }
        if (invDirZ >= 0) {
            tzmin = (minZ - z) * invDirZ;
            tzmax = (maxZ - z) * invDirZ;
        }
        else {
            tzmin = (maxZ - z) * invDirZ;
            tzmax = (minZ - z) * invDirZ;
        }
        if (tymin > tmin)
            tmin = tymin;
        if (tymax < tmax)
            tmax = tymax;
        if (tzmin > tmin)
            tmin = tzmin;
        if (tzmax < tmax)
            tmax = tzmax;
        linear_algebra_1.Vec3.scale(out, dir, tmin);
        return linear_algebra_1.Vec3.set(out, out[0] + x, out[1] + y, out[2] + z);
    }
    Box3D.nearestIntersectionWithRay = nearestIntersectionWithRay;
})(Box3D || (Box3D = {}));
exports.Box3D = Box3D;
