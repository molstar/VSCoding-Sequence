"use strict";
/**
 * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Fred Ludlow <Fred.Ludlow@astx.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcPlaneAngle = exports.calcAngles = exports.AtomGeometryAngles = exports.assignGeometry = exports.geometryLabel = void 0;
var misc_1 = require("../../../mol-math/misc");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var util_1 = require("./util");
function geometryLabel(geometry) {
    switch (geometry) {
        case 0 /* AtomGeometry.Spherical */:
            return 'Spherical';
        case 1 /* AtomGeometry.Terminal */:
            return 'Terminal';
        case 2 /* AtomGeometry.Linear */:
            return 'Linear';
        case 3 /* AtomGeometry.Trigonal */:
            return 'Trigonal';
        case 4 /* AtomGeometry.Tetrahedral */:
            return 'Tetrahedral';
        case 5 /* AtomGeometry.TrigonalBiPyramidal */:
            return 'Trigonal Bi-Pyramidal';
        case 6 /* AtomGeometry.Octahedral */:
            return 'Octahedral';
        case 7 /* AtomGeometry.SquarePlanar */:
            return 'Square Planar';
        case 8 /* AtomGeometry.Unknown */:
            return 'Unknown';
    }
}
exports.geometryLabel = geometryLabel;
function assignGeometry(totalCoordination) {
    switch (totalCoordination) {
        case 0: return 0 /* AtomGeometry.Spherical */;
        case 1: return 1 /* AtomGeometry.Terminal */;
        case 2: return 2 /* AtomGeometry.Linear */;
        case 3: return 3 /* AtomGeometry.Trigonal */;
        case 4: return 4 /* AtomGeometry.Tetrahedral */;
        default: return 8 /* AtomGeometry.Unknown */;
    }
}
exports.assignGeometry = assignGeometry;
exports.AtomGeometryAngles = new Map([
    [2 /* AtomGeometry.Linear */, (0, misc_1.degToRad)(180)],
    [3 /* AtomGeometry.Trigonal */, (0, misc_1.degToRad)(120)],
    [4 /* AtomGeometry.Tetrahedral */, (0, misc_1.degToRad)(109.4721)],
    [6 /* AtomGeometry.Octahedral */, (0, misc_1.degToRad)(90)]
]);
// tmp objects for `calcAngles` and `calcPlaneAngle`
var tmpDir1 = (0, linear_algebra_1.Vec3)();
var tmpDir2 = (0, linear_algebra_1.Vec3)();
var tmpPosA = (0, linear_algebra_1.Vec3)();
var tmpPosB = (0, linear_algebra_1.Vec3)();
var tmpPosX = (0, linear_algebra_1.Vec3)();
/**
 * Calculate the angles x-a1-a2 for all x where x is a heavy atom (not H) bonded to ap1.
 */
function calcAngles(structure, unitA, indexA, unitB, indexB) {
    var angles = [];
    unitA.conformation.position(unitA.elements[indexA], tmpPosA);
    unitB.conformation.position(unitB.elements[indexB], tmpPosB);
    linear_algebra_1.Vec3.sub(tmpDir1, tmpPosB, tmpPosA);
    (0, util_1.eachBondedAtom)(structure, unitA, indexA, function (unitX, indexX) {
        if ((0, util_1.typeSymbol)(unitX, indexX) !== "H" /* Elements.H */) {
            unitX.conformation.position(unitX.elements[indexX], tmpPosX);
            linear_algebra_1.Vec3.sub(tmpDir2, tmpPosX, tmpPosA);
            angles.push(linear_algebra_1.Vec3.angle(tmpDir1, tmpDir2));
        }
    });
    return angles;
}
exports.calcAngles = calcAngles;
/**
 * Find two neighbours of ap1 to define a plane (if possible) and
 * measure angle out of plane to ap2
 * @param  {AtomProxy} ap1 First atom (angle centre)
 * @param  {AtomProxy} ap2 Second atom (out-of-plane)
 * @return {number}        Angle from plane to second atom
 */
function calcPlaneAngle(structure, unitA, indexA, unitB, indexB) {
    unitA.conformation.position(unitA.elements[indexA], tmpPosA);
    unitB.conformation.position(unitB.elements[indexB], tmpPosB);
    linear_algebra_1.Vec3.sub(tmpDir1, tmpPosB, tmpPosA);
    var neighbours = [(0, linear_algebra_1.Vec3)(), (0, linear_algebra_1.Vec3)()];
    var ni = 0;
    var unitX1;
    var indexX1;
    (0, util_1.eachBondedAtom)(structure, unitA, indexA, function (unitX, indexX) {
        if (ni > 1)
            return;
        if ((0, util_1.typeSymbol)(unitX, indexX) !== "H" /* Elements.H */) {
            unitX1 = unitX;
            indexX1 = indexX;
            unitX.conformation.position(unitX.elements[indexX], tmpPosX);
            linear_algebra_1.Vec3.sub(neighbours[ni++], tmpPosX, tmpPosA);
        }
    });
    if (ni === 1 && unitX1 && indexX1) {
        (0, util_1.eachBondedAtom)(structure, unitX1, indexX1, function (unitX, indexX) {
            if (ni > 1)
                return;
            if (unitX === unitA && indexX === indexA)
                return;
            if ((0, util_1.typeSymbol)(unitX, indexX) !== "H" /* Elements.H */) {
                unitX.conformation.position(unitX.elements[indexX], tmpPosX);
                linear_algebra_1.Vec3.sub(neighbours[ni++], tmpPosX, tmpPosA);
            }
        });
    }
    if (ni !== 2) {
        return;
    }
    linear_algebra_1.Vec3.cross(tmpDir2, neighbours[0], neighbours[1]);
    return Math.abs((Math.PI / 2) - linear_algebra_1.Vec3.angle(tmpDir2, tmpDir1));
}
exports.calcPlaneAngle = calcPlaneAngle;
