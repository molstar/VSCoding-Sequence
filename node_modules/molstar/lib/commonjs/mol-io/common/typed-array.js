"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * Taken/adapted from DensityServer (https://github.com/dsehnal/DensityServer)
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.readTypedArray = exports.createTypedArrayBufferContext = exports.createTypedArray = exports.makeTypedArray = exports.getElementByteSize = exports.TypedArrayValueType = void 0;
var tslib_1 = require("tslib");
var simple_buffer_1 = require("../../mol-io/common/simple-buffer");
var TypedArrayValueType;
(function (TypedArrayValueType) {
    TypedArrayValueType.Float32 = 'float32';
    TypedArrayValueType.Int8 = 'int8';
    TypedArrayValueType.Int16 = 'int16';
    TypedArrayValueType.Uint16 = 'uint16';
})(TypedArrayValueType = exports.TypedArrayValueType || (exports.TypedArrayValueType = {}));
function getElementByteSize(type) {
    if (type === TypedArrayValueType.Float32)
        return 4;
    if (type === TypedArrayValueType.Int16)
        return 2;
    if (type === TypedArrayValueType.Uint16)
        return 2;
    return 1;
}
exports.getElementByteSize = getElementByteSize;
function makeTypedArray(type, buffer, byteOffset, length) {
    if (byteOffset === void 0) { byteOffset = 0; }
    if (type === TypedArrayValueType.Float32)
        return new Float32Array(buffer, byteOffset, length);
    if (type === TypedArrayValueType.Int16)
        return new Int16Array(buffer, byteOffset, length);
    if (type === TypedArrayValueType.Uint16)
        return new Uint16Array(buffer, byteOffset, length);
    return new Int8Array(buffer, byteOffset, length);
}
exports.makeTypedArray = makeTypedArray;
function createTypedArray(type, size) {
    switch (type) {
        case TypedArrayValueType.Float32: return new Float32Array(new ArrayBuffer(4 * size));
        case TypedArrayValueType.Int8: return new Int8Array(new ArrayBuffer(1 * size));
        case TypedArrayValueType.Int16: return new Int16Array(new ArrayBuffer(2 * size));
        case TypedArrayValueType.Uint16: return new Uint16Array(new ArrayBuffer(2 * size));
    }
    throw Error("".concat(type, " is not a supported value format."));
}
exports.createTypedArray = createTypedArray;
function createTypedArrayBufferContext(size, type) {
    var elementByteSize = getElementByteSize(type);
    var arrayBuffer = new ArrayBuffer(elementByteSize * size);
    var readBuffer = simple_buffer_1.SimpleBuffer.fromArrayBuffer(arrayBuffer);
    var valuesBuffer = simple_buffer_1.SimpleBuffer.IsNativeEndianLittle ? arrayBuffer : new ArrayBuffer(elementByteSize * size);
    return {
        type: type,
        elementByteSize: elementByteSize,
        readBuffer: readBuffer,
        valuesBuffer: new Uint8Array(valuesBuffer),
        values: makeTypedArray(type, valuesBuffer)
    };
}
exports.createTypedArrayBufferContext = createTypedArrayBufferContext;
function readTypedArray(ctx, file, position, byteCount, valueByteOffset, littleEndian) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, file.readBuffer(position, ctx.readBuffer, byteCount, valueByteOffset)];
                case 1:
                    _a.sent();
                    if (ctx.elementByteSize > 1 && ((littleEndian !== void 0 && littleEndian !== simple_buffer_1.SimpleBuffer.IsNativeEndianLittle) || !simple_buffer_1.SimpleBuffer.IsNativeEndianLittle)) {
                        // fix the endian
                        simple_buffer_1.SimpleBuffer.flipByteOrder(ctx.readBuffer, ctx.valuesBuffer, byteCount, ctx.elementByteSize, valueByteOffset);
                    }
                    return [2 /*return*/, ctx.values];
            }
        });
    });
}
exports.readTypedArray = readTypedArray;
//# sourceMappingURL=typed-array.js.map