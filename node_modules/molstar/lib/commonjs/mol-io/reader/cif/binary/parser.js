"use strict";
/**
 * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCifBinary = void 0;
var tslib_1 = require("tslib");
var Data = (0, tslib_1.__importStar)(require("../data-model"));
var field_1 = require("./field");
var result_1 = require("../../result");
var decode_1 = require("../../../common/msgpack/decode");
var mol_task_1 = require("../../../../mol-task");
function checkVersions(min, current) {
    for (var i = 0; i < 2; i++) {
        if (min[i] > current[i])
            return false;
    }
    return true;
}
function Category(data) {
    var map = Object.create(null);
    var cache = Object.create(null);
    for (var _i = 0, _a = data.columns; _i < _a.length; _i++) {
        var col = _a[_i];
        map[col.name] = col;
    }
    return {
        rowCount: data.rowCount,
        name: data.name.substr(1),
        fieldNames: data.columns.map(function (c) { return c.name; }),
        getField: function (name) {
            var col = map[name];
            if (!col)
                return void 0;
            if (!!cache[name])
                return cache[name];
            cache[name] = (0, field_1.Field)(col);
            return cache[name];
        }
    };
}
function parseCifBinary(data) {
    var _this = this;
    return mol_task_1.Task.create('Parse BinaryCIF', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
        var minVersion, unpacked, file;
        return (0, tslib_1.__generator)(this, function (_a) {
            minVersion = [0, 3];
            try {
                unpacked = (0, decode_1.decodeMsgPack)(data);
                if (!checkVersions(minVersion, unpacked.version.match(/(\d)\.(\d)\.\d/).slice(1).map(function (v) { return +v; }))) {
                    return [2 /*return*/, result_1.ReaderResult.error("Unsupported format version. Current ".concat(unpacked.version, ", required ").concat(minVersion.join('.'), "."))];
                }
                file = Data.CifFile(unpacked.dataBlocks.map(function (block) {
                    var cats = Object.create(null);
                    for (var _i = 0, _a = block.categories; _i < _a.length; _i++) {
                        var cat = _a[_i];
                        cats[cat.name.substr(1)] = Category(cat);
                    }
                    return Data.CifBlock(block.categories.map(function (c) { return c.name.substr(1); }), cats, block.header);
                }));
                return [2 /*return*/, result_1.ReaderResult.success(file)];
            }
            catch (e) {
                return [2 /*return*/, result_1.ReaderResult.error('' + e)];
            }
            return [2 /*return*/];
        });
    }); });
}
exports.parseCifBinary = parseCifBinary;
//# sourceMappingURL=parser.js.map