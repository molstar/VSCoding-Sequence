/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { ValueCell } from '../../mol-util';
import { LocationIterator } from '../util/location-iterator';
import { ParamDefinition as PD } from '../../mol-util/param-definition';
import { createIdentityTransform } from './transform-data';
import { ColorNames } from '../../mol-util/color/names';
import { NullLocation } from '../../mol-model/location';
import { UniformColorTheme } from '../../mol-theme/color/uniform';
import { UniformSizeTheme } from '../../mol-theme/size/uniform';
import { smoothstep } from '../../mol-math/interpolate';
export var VisualQualityInfo = {
    'custom': {},
    'auto': {},
    'highest': {},
    'higher': {},
    'high': {},
    'medium': {},
    'low': {},
    'lower': {},
    'lowest': {},
};
export var VisualQualityNames = Object.keys(VisualQualityInfo);
export var VisualQualityOptions = PD.arrayToOptions(VisualQualityNames);
//
export var ColorSmoothingParams = {
    smoothColors: PD.MappedStatic('auto', {
        auto: PD.Group({}),
        on: PD.Group({
            resolutionFactor: PD.Numeric(2, { min: 0.5, max: 6, step: 0.1 }),
            sampleStride: PD.Numeric(3, { min: 1, max: 12, step: 1 }),
        }),
        off: PD.Group({})
    }),
};
export function hasColorSmoothingProp(props) {
    return !!props.smoothColors;
}
export function getColorSmoothingProps(smoothColors, preferSmoothing, resolution) {
    if ((smoothColors.name === 'on' || (smoothColors.name === 'auto' && preferSmoothing)) && resolution && resolution < 3) {
        var stride = 3;
        if (smoothColors.name === 'on') {
            resolution *= smoothColors.params.resolutionFactor;
            stride = smoothColors.params.sampleStride;
        }
        else {
            // https://graphtoy.com/?f1(x,t)=(2-smoothstep(0,1.1,x))*x&coords=0.7,0.6,1.8
            resolution *= 2 - smoothstep(0, 1.1, resolution);
            resolution = Math.max(0.5, resolution);
            if (resolution > 1.2)
                stride = 2;
        }
        return { resolution: resolution, stride: stride };
    }
    ;
}
//
export var BaseGeometry;
(function (BaseGeometry) {
    BaseGeometry.Params = {
        alpha: PD.Numeric(1, { min: 0, max: 1, step: 0.01 }, { label: 'Opacity', isEssential: true, description: 'How opaque/transparent the representation is rendered.' }),
        quality: PD.Select('auto', VisualQualityOptions, { isEssential: true, description: 'Visual/rendering quality of the representation.' }),
    };
    BaseGeometry.ShadingCategory = { category: 'Shading' };
    BaseGeometry.CustomQualityParamInfo = {
        category: 'Custom Quality',
        hideIf: function (params) { return typeof params.quality !== 'undefined' && params.quality !== 'custom'; }
    };
    function createSimple(colorValue, sizeValue, transform) {
        if (colorValue === void 0) { colorValue = ColorNames.grey; }
        if (sizeValue === void 0) { sizeValue = 1; }
        if (!transform)
            transform = createIdentityTransform();
        var locationIterator = LocationIterator(1, transform.instanceCount.ref.value, 1, function () { return NullLocation; }, false, function () { return false; });
        var theme = {
            color: UniformColorTheme({}, { value: colorValue }),
            size: UniformSizeTheme({}, { value: sizeValue })
        };
        return { transform: transform, locationIterator: locationIterator, theme: theme };
    }
    BaseGeometry.createSimple = createSimple;
    function createValues(props, counts) {
        return {
            alpha: ValueCell.create(props.alpha),
            uAlpha: ValueCell.create(props.alpha),
            uVertexCount: ValueCell.create(counts.vertexCount),
            uGroupCount: ValueCell.create(counts.groupCount),
            drawCount: ValueCell.create(counts.drawCount),
        };
    }
    BaseGeometry.createValues = createValues;
    function updateValues(values, props) {
        ValueCell.updateIfChanged(values.alpha, props.alpha); // `uAlpha` is set in renderable.render
    }
    BaseGeometry.updateValues = updateValues;
    function createRenderableState(props) {
        if (props === void 0) { props = {}; }
        var opaque = props.alpha === undefined ? true : props.alpha === 1;
        return {
            disposed: false,
            visible: true,
            alphaFactor: 1,
            pickable: true,
            colorOnly: false,
            opaque: opaque,
            writeDepth: opaque,
            noClip: false,
        };
    }
    BaseGeometry.createRenderableState = createRenderableState;
    function updateRenderableState(state, props) {
        state.opaque = props.alpha * state.alphaFactor >= 1;
        state.writeDepth = state.opaque;
    }
    BaseGeometry.updateRenderableState = updateRenderableState;
})(BaseGeometry || (BaseGeometry = {}));
//# sourceMappingURL=base.js.map